<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>JavaScript Variables – Interview Guide</title>
    <style>
      body {
        font-family: "Segoe UI", sans-serif;
        margin: 40px;
        background: #ffffff;
        color: #2c3e50;
        margin-left: 100px;
      }
      h1 {
        color: #2980b9;
        text-align: center;
      }
      h2 {
        color: #e67e22;
        margin-top: 30px;
      }
      .question {
        margin-top: 20px;
        font-weight: bold;
        color: #34495e;
      }
      .answer {
        margin-top: 5px;
        margin-bottom: 20px;
        line-height: 1.6;
      }
      pre {
        background-color: #ecf0f1;
        color: #2c3e50;
        padding: 10px;
        border-left: 5px solid #3498db;
        border-radius: 4px;
        overflow-x: auto;
      }
      code {
        font-family: Consolas, "Courier New", monospace;
      }
    </style>
  </head>
  <body>
    <h2>1. JavaScript Variables</h2>

    <div class="question">1. What are variables in JavaScript?</div>
    <div class="answer">
      Variables are containers used to store data values. JavaScript uses
      <code>var</code>, <code>let</code>, and <code>const</code> to declare
      variables.
    </div>

    <div class="question">2. How do you declare a variable in JavaScript?</div>
    <div class="answer">
      You can declare variables using:
      <pre><code>var name = "Akshay";
let age = 25;
const country = "India";</code></pre>
    </div>

    <div class="question">
      3. What is the difference between var, let, and const?
    </div>
    <div class="answer">
      <ul>
        <li>
          <code>var</code>: function-scoped, hoisted, can be redeclared and
          reassigned
        </li>
        <li>
          <code>let</code>: block-scoped, cannot be redeclared, can be
          reassigned
        </li>
        <li>
          <code>const</code>: block-scoped, cannot be redeclared or reassigned
        </li>
      </ul>
    </div>

    <h2>Intermediate Questions</h2>

    <div class="question">
      6. What is hoisting in JavaScript and how does it affect var, let, and
      const?
    </div>
    <div class="answer">
      Variable declarations are moved to the top of their scope. Example:
      <pre><code>console.log(x); // undefined
var x = 10;

console.log(y); // ReferenceError
let y = 10;</code></pre>
    </div>

    <div class="question">7. What is the Temporal Dead Zone (TDZ)?</div>
    <div class="answer">
      TDZ is the phase between the block start and variable declaration where
      accessing the variable causes a ReferenceError.
    </div>

    <div class="question">9. What is block scope vs function scope?</div>
    <div class="answer">
      <pre><code>function test() {
  var a = 5;
}
console.log(a); // ReferenceError

if (true) {
  let b = 10;
}
console.log(b); // ReferenceError</code></pre>
    </div>

    <h2>Advanced Questions</h2>

    <div class="question">14. How do closures interact with variables?</div>
    <div class="answer">
      Closures capture variables from outer lexical scopes:
      <pre><code>function outer() {
  let count = 0;
  return function inner() {
    count++;
    console.log(count);
  };
}
const counter = outer();
counter(); // 1
counter(); // 2</code></pre>
    </div>

    <div class="question">15. How do var, let, and const behave in loops?</div>
    <div class="answer">
      <pre><code>for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1000); // 3 3 3
}

for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1000); // 0 1 2
}</code></pre>
    </div>

    <h2>Trick Questions</h2>

    <div class="question">Trick 1: What will this output?</div>
    <div class="answer">
      <pre><code>console.log(x);
var x = 10;
// Output: undefined (due to hoisting)</code></pre>
    </div>

    <div class="question">Trick 2: What about this?</div>
    <div class="answer">
      <pre><code>console.log(y);
let y = 10;
// Output: ReferenceError (due to TDZ)</code></pre>
    </div>

    <div class="question">Trick 3: Can you redeclare a var?</div>
    <div class="answer">
      <pre><code>var a = 5;
var a = 10;
console.log(a); // Output: 10</code></pre>
    </div>

    <section>
      <h2>2. JavaScript Primitive Data Types</h2>

      <p>JavaScript has 7 primitive data types:</p>
      <ul>
        <li>
          <strong>Number</strong> – numeric values (e.g., <code>10</code>,
          <code>3.14</code>)
        </li>
        <li>
          <strong>String</strong> – textual data (e.g., <code>'Hello'</code>,
          <code>"World"</code>)
        </li>
        <li>
          <strong>Boolean</strong> – logical values: <code>true</code> or
          <code>false</code>
        </li>
        <li>
          <strong>Null</strong> – intentional absence of any value
          (<code>null</code>)
        </li>
        <li><strong>Undefined</strong> – uninitialized variable</li>
        <li><strong>Symbol</strong> – unique and immutable value</li>
        <li>
          <strong>BigInt</strong> – large integers beyond
          <code>Number.MAX_SAFE_INTEGER</code>
        </li>
      </ul>

      <h3>1. Number</h3>
      <pre><code>let score = 42;
      typeof score; // "number"</code></pre>

      <h3>2. String</h3>
      <pre><code>let name = "JavaScript";
      typeof name; // "string"</code></pre>

      <h3>3. Boolean</h3>
      <pre><code>let isReady = true;
      typeof isReady; // "boolean"</code></pre>

      <h3>4. Null</h3>
      <pre><code>let data = null;
      typeof data; // "object" (known bug)</code></pre>

      <h3>5. Undefined</h3>
      <pre><code>let result;
      typeof result; // "undefined"</code></pre>

      <h3>6. Symbol</h3>
      <pre><code>let id = Symbol("id");
      typeof id; // "symbol"</code></pre>

      <h3>7. BigInt</h3>
      <pre><code>let bigNumber = 12345678901234567890n;
      typeof bigNumber; // "bigint"</code></pre>
    </section>

    <section>
      <h2>Tricky Questions on Primitive Data Types</h2>

      <div class="question">Q1: What is the type of <code>null</code>?</div>
      <div class="answer">
        <pre><code>console.log(typeof null); // "object"</code></pre>
        This is a well-known JavaScript bug. <code>null</code> is a primitive,
        but <code>typeof null</code> incorrectly returns "object".
      </div>

      <div class="question">Q2: What is the output of the following?</div>
      <div class="answer">
        <pre><code>let a;
      console.log(a + 1); // NaN</code></pre>
        <code>a</code> is <code>undefined</code>. So
        <code>undefined + 1</code> results in <code>NaN</code>.
      </div>

      <div class="question">Q3: What is the type of <code>NaN</code>?</div>
      <div class="answer">
        <pre><code>console.log(typeof NaN); // "number"</code></pre>
        Even though NaN means "Not a Number", it is still of type
        <code>number</code>.
      </div>

      <div class="question">
        Q4: What is the result of comparing two symbols?
      </div>
      <div class="answer">
        <pre><code>let x = Symbol("foo");
      let y = Symbol("foo");
      console.log(x === y); // false</code></pre>
        Each <code>Symbol()</code> is unique, even with the same description.
      </div>

      <div class="question">Q5: What happens when reassigning a const?</div>
      <div class="answer">
        <pre><code>const a = 10;
      a = 20; // TypeError</code></pre>
        <code>const</code> variables cannot be reassigned.
      </div>

      <div class="question">Q6: What is the type of a BigInt literal?</div>
      <div class="answer">
        <pre><code>console.log(typeof 12345678901234567890n); // "bigint"</code></pre>
      </div>

      <div class="question">Q7: What is the result of adding null to 1?</div>
      <div class="answer">
        <pre><code>let a = null;
      console.log(a + 1); // 1</code></pre>
        <code>null</code> is coerced to <code>0</code> in numeric operations.
      </div>

      <div class="question">Q8: Which are primitives in the list?</div>
      <div class="answer">
        <pre><code>1, 'hello', true, null, undefined, Symbol(), {}, []</code></pre>
        All except <code>{}</code> and <code>[]</code> are primitives. The
        latter two are reference types (object and array).
      </div>

      <div class="question">Q9: What is <code>typeof undefined</code>?</div>
      <div class="answer">
        <pre><code>typeof undefined; // "undefined"</code></pre>
      </div>

      <div class="question">Q10: What is <code>typeof typeof 123</code>?</div>
      <div class="answer">
        <pre><code>typeof typeof 123; // "string"</code></pre>
        <code>typeof 123</code> is <code>"number"</code>, and
        <code>typeof "number"</code> is <code>"string"</code>.
      </div>
    </section>

    <section>
      <h2>3. Type Coercion in JavaScript</h2>
      <p>
        Type coercion is JavaScript's way of automatically converting data types
        when needed.
      </p>

      <h3>1. Implicit Coercion</h3>
      <pre><code>'5' + 1    // "51"
      '5' - 1    // 4
      true + 1   // 2
      null + 1   // 1</code></pre>

      <h3>2. Explicit Coercion</h3>
      <pre><code>Number('123')       // 123
      String(123)         // "123"
      Boolean(0)          // false</code></pre>

      <h3>Boolean Coercion Table</h3>
      <ul>
        <li><code>false, 0, "", null, undefined, NaN</code> → false</li>
        <li>Everything else → true</li>
      </ul>

      <h3>Tricky Examples</h3>
      <pre><code>[] + {}          // "[object Object]"
      {} + []          // 0
      [] == ![]        // true
      false == '0'     // true
      null == undefined // true
      0 == ''          // true
      0 === ''         // false</code></pre>

      <h3>Tricky Questions</h3>

      <div class="question">
        Q1: What is the output of <code>'5' + 2 + 3</code>?
      </div>
      <div class="answer"><code>"523"</code></div>

      <div class="question">Q2: What is <code>true + false</code>?</div>
      <div class="answer"><code>1</code></div>

      <div class="question">Q3: What is <code>null + undefined</code>?</div>
      <div class="answer"><code>NaN</code></div>

      <div class="question">Q4: What is <code>[] == ![]</code>?</div>
      <div class="answer"><code>true</code></div>
    </section>

    <section>
      <h2>4. Difference Between <code>==</code> and <code>===</code></h2>

      <p>
        <strong><code>==</code> (Loose Equality):</strong> Compares only values
        after type coercion.
      </p>
      <p>
        <strong><code>===</code> (Strict Equality):</strong> Compares both value
        and type without coercion.
      </p>

      <h3>Examples</h3>
      <pre><code>'5' == 5     // true
      '5' === 5    // false
      0 == false   // true
      0 === false  // false
      null == undefined  // true
      null === undefined // false</code></pre>

      <h3>When to Use</h3>
      <p>
        Always prefer <code>===</code> to avoid bugs due to automatic type
        conversion.
      </p>

      <h3>Tricky Interview Questions</h3>

      <div class="question">Q1: What is <code>[] == false</code>?</div>
      <div class="answer">
        <code>true</code> (because <code>[]</code> becomes <code>0</code>)
      </div>

      <div class="question">Q2: What is <code>[] === false</code>?</div>
      <div class="answer">
        <code>false</code> (strict type mismatch: object vs boolean)
      </div>

      <div class="question">Q3: What is <code>null == undefined</code>?</div>
      <div class="answer"><code>true</code> (special equality case)</div>

      <div class="question">Q4: What is <code>NaN == NaN</code>?</div>
      <div class="answer">
        <code>false</code> (NaN is never equal to itself)
      </div>
    </section>

    <section>
      <h2>5. ✅ Why is <code>Number.isNaN("hello")</code> False?</h2>
      <p>
        <strong>Short Answer:</strong> Because <code>"hello"</code> is a
        <em>string</em>, not the actual <code>NaN</code> value.
      </p>

      <h3>🔍 Detailed Explanation:</h3>
      <ul>
        <li>
          <code>Number.isNaN(value)</code> checks
          <strong>strictly</strong> whether the value is exactly
          <code>NaN</code>.
        </li>
        <li>
          <code>"hello"</code> is a string, not the <code>NaN</code> value.
        </li>
        <li>
          Even though <code>Number("hello")</code> returns <code>NaN</code>,
          <code>"hello"</code> itself is not <code>NaN</code>.
        </li>
      </ul>

      <pre><code>Number("hello");        // NaN
      Number.isNaN("hello");  // false ✅
      isNaN("hello");         // true ❌</code></pre>

      <p>
        <strong>So:</strong> Always use <code>Number.isNaN()</code> when you
        want a precise check for the actual <code>NaN</code> value without
        coercion.
      </p>
    </section>

    <section>
      <h2>6. 📌 JavaScript <code>typeof</code> Operator</h2>

      <p>
        The <code>typeof</code> operator is used to determine the
        <strong>data type</strong> of a given value. It returns the type as a
        <code>string</code>.
      </p>

      <h3>✅ Syntax</h3>
      <pre><code>typeof operand
      typeof(operand)</code></pre>

      <h3>✅ Examples</h3>
      <table border="1" cellpadding="8" cellspacing="0">
        <thead>
          <tr>
            <th>Expression</th>
            <th>Result</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>typeof "hello"</code></td>
            <td>"string"</td>
          </tr>
          <tr>
            <td><code>typeof 42</code></td>
            <td>"number"</td>
          </tr>
          <tr>
            <td><code>typeof true</code></td>
            <td>"boolean"</td>
          </tr>
          <tr>
            <td><code>typeof undefined</code></td>
            <td>"undefined"</td>
          </tr>
          <tr>
            <td><code>typeof null</code></td>
            <td>"object"</td>
          </tr>
          <tr>
            <td><code>typeof {}</code></td>
            <td>"object"</td>
          </tr>
          <tr>
            <td><code>typeof []</code></td>
            <td>"object"</td>
          </tr>
          <tr>
            <td><code>typeof function() {}</code></td>
            <td>"function"</td>
          </tr>
          <tr>
            <td><code>typeof NaN</code></td>
            <td>"number"</td>
          </tr>
        </tbody>
      </table>

      <h3>⚠️ Gotchas</h3>
      <ul>
        <li>
          <code>typeof null</code> returns <code>"object"</code> – a known bug
          in JavaScript for historical reasons.
        </li>
        <li>
          <code>typeof []</code> also returns <code>"object"</code> – use
          <code>Array.isArray()</code> to check for arrays.
        </li>
      </ul>

      <h3>💡 Pro Tip</h3>
      <p>
        Use <code>typeof</code> for primitives. For complex types like arrays,
        functions, or classes, use <code>Array.isArray()</code> or
        <code>instanceof</code> for better accuracy.
      </p>
    </section>

    <section>
        <h2>8. JavaScript Function Concepts</h2>
      
        <h3>1. What is a Function Statement?</h3>
        <p>
          A normal function that we create using a naming convention.<br>
          It is <strong>hoisted</strong> — meaning it can be called before it's defined.
        </p>
        <pre><code>function xyz() {
        console.log("Function Statement");
      }</code></pre>
      
        <h3>2. What is a Function Expression?</h3>
        <p>
          When we assign a function into a variable, it's called a function expression.<br>
          It is <strong>not hoisted</strong> because it behaves like a variable.
        </p>
        <pre><code>var a = function() {
        console.log("Function Expression");
      };</code></pre>
      
        <h3>3. What is an Anonymous Function?</h3>
        <p>
          A function <strong>without a name</strong> is called an anonymous function.<br>
          It is commonly used where functions are treated as values, like in callbacks.
        </p>
        <pre><code>function() {
        // Invalid alone – must be assigned or used immediately
      }</code></pre>
      
        <h3>4. What is a Named Function Expression?</h3>
        <p>
          A function expression with a name.
        </p>
        <pre><code>var a = function xyz() {
        console.log("Named Function Expression");
      };</code></pre>
      
        <h3>5. Difference between Parameters and Arguments?</h3>
        <p>
          - <strong>Parameters</strong>: Variables listed in a function's definition.<br>
          - <strong>Arguments</strong>: Actual values passed when calling the function.
        </p>
        <pre><code>// Parameters
      function ab(param1, param2) {
        console.log(param1 + param2);
      }
      
      // Arguments
      ab(4, 5);</code></pre>
      
        <h3>6. What is a First-Class Function / First-Class Citizen?</h3>
        <p>
          Functions in JavaScript are first-class citizens. They can:
          <ul>
            <li>Be assigned to variables</li>
            <li>Be passed as arguments</li>
            <li>Be returned from other functions</li>
          </ul>
        </p>
        <pre><code>var b = function(param) {
        return function xyz() {
          console.log("F C F");
        };
      };</code></pre>
      
        <h3>7. Summary</h3>
        <p>
          Functions are the <strong>heart of JavaScript</strong>. They are called
          <em>first-class citizens</em> because:
        </p>
        <ul>
          <li>They can be stored in variables</li>
          <li>They can be passed as parameters or arguments</li>
          <li>They can be returned from other functions</li>
        </ul>
    </section>

    <section>
        <h2>7. Truthy and Falsy Values in JavaScript</h2>
      
        <p>
          In JavaScript, values are either <strong>truthy</strong> or <strong>falsy</strong>
          when evaluated in a boolean context (like in <code>if</code> statements).
        </p>
      
        <h3>❌ Falsy Values</h3>
        <p>These values are treated as <strong>false</strong> in boolean contexts:</p>
        <ul>
          <li><code>false</code></li>
          <li><code>0</code></li>
          <li><code>-0</code></li>
          <li><code>0n</code> <em>(BigInt zero)</em></li>
          <li><code>""</code> <em>(empty string)</em></li>
          <li><code>null</code></li>
          <li><code>undefined</code></li>
          <li><code>NaN</code></li>
        </ul>
      
        <h3>✅ Truthy Values</h3>
        <p>Any value that is not falsy is considered <strong>truthy</strong>:</p>
        <ul>
          <li><code>true</code></li>
          <li><code>1</code>, <code>-1</code>, <code>42</code> <em>(any non-zero number)</em></li>
          <li><code>"hello"</code>, <code>"0"</code> <em>(any non-empty string)</em></li>
          <li><code>[]</code>, <code>{}</code> <em>(empty array and object)</em></li>
          <li><code>function() {}</code> <em>(functions)</em></li>
          <li><code>Infinity</code>, <code>-Infinity</code></li>
        </ul>
      
        <h3>🔎 Examples</h3>
        <pre><code>if ("hello") {
        console.log("This is truthy!");
      }
      
      if (0) {
        console.log("This won't run — 0 is falsy.");
      }</code></pre>
      
        <h3>⚠️ Gotchas</h3>
        <table border="1" cellpadding="6">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Boolean Value</th>
            </tr>
          </thead>
          <tbody>
            <tr><td><code>""</code></td><td>Falsy</td></tr>
            <tr><td><code>" "</code></td><td>Truthy</td></tr>
            <tr><td><code>[]</code></td><td>Truthy</td></tr>
            <tr><td><code>{}</code></td><td>Truthy</td></tr>
            <tr><td><code>"0"</code></td><td>Truthy</td></tr>
            <tr><td><code>null</code></td><td>Falsy</td></tr>
            <tr><td><code>NaN</code></td><td>Falsy</td></tr>
          </tbody>
        </table>
      
        <h3>💡 Interview Tip</h3>
        <p>
          Memorize the <strong>7 falsy values</strong>. This helps prevent bugs in conditional logic and understand how JavaScript coerces values.
        </p>
    </section>    
    
    <section>
        <h2>9. 🔍 What is the Scope of a Variable in JavaScript?</h2>
      
        <p>
          <strong>Scope</strong> defines where in your code a variable is accessible. It determines
          the <em>visibility</em> of variables — whether they can be used globally or only within
          specific blocks or functions.
        </p>
      
        <h3>✅ 1. Global Scope</h3>
        <p>
          A variable declared outside of any function or block. It's accessible anywhere in the code.
        </p>
        <pre><code>var globalVar = "I am global";
      
      function printGlobal() {
        console.log(globalVar); // ✅ Accessible here
      }</code></pre>
      
        <h3>✅ 2. Function (Local) Scope</h3>
        <p>
          A variable declared inside a function is accessible only within that function.
        </p>
        <pre><code>function greet() {
        let message = "Hello";
        console.log(message); // ✅ Accessible here
      }
      
      console.log(message); // ❌ Error: message is not defined</code></pre>
      
        <h3>✅ 3. Block Scope (with <code>let</code> and <code>const</code>)</h3>
        <p>
          Variables declared inside a block <code>{ ... }</code> using <code>let</code> or <code>const</code>
          are only accessible within that block.
        </p>
        <pre><code>if (true) {
        let name = "Alice";
        const age = 25;
        console.log(name); // ✅ Accessible
      }
      
      console.log(name); // ❌ Error: name is not defined</code></pre>
      
        <h3>✅ 4. Lexical Scope</h3>
        <p>
          JavaScript uses <strong>lexical scoping</strong>, meaning the scope is determined by the
          <em>physical placement of code</em> (where it’s written).
        </p>
        <pre><code>function outer() {
        let outerVar = "outside";
      
        function inner() {
          console.log(outerVar); // ✅ Can access parent's variable
        }
      
        inner();
      }</code></pre>
      
        <h3>💡 Interview Tip</h3>
        <p>
          Always prefer <code>let</code> and <code>const</code> over <code>var</code> to avoid scope-related bugs.
          Understand the difference between function scope and block scope clearly.
        </p>
    </section>
    
    <section>
        <h2>10. 🌐 Is <code>let</code> at the Top of a Program Global Scope?</h2>
      
        <p>
          If you declare a variable with <code>let</code> at the top of a JavaScript file,
          it is <strong>global in scope</strong> <em>within the script or module</em>,
          but <strong>it is not attached to the <code>window</code> object</strong> in browsers.
        </p>
      
        <h3>🧠 Example:</h3>
        <pre><code>let a = 10;
      var b = 20;
      
      console.log(window.a); // ❌ undefined
      console.log(window.b); // ✅ 20
      </code></pre>
      
        <p>
          - <code>let a = 10;</code> is globally scoped, but <strong>not a property of</strong> <code>window</code>.<br>
          - <code>var b = 20;</code> is globally scoped <strong>and</strong> added to the <code>window</code> object.
        </p>
      
        <h3>📦 In ES6 Modules</h3>
        <p>
          Even top-level variables declared with <code>let</code> or <code>const</code> are scoped
          to the module — not the global object.
        </p>
      
        <h3>✅ Summary Table</h3>
        <table border="1" cellpadding="6">
          <thead>
            <tr>
              <th>Declaration</th>
              <th>Scope</th>
              <th>Attached to <code>window</code>?</th>
            </tr>
          </thead>
          <tbody>
            <tr><td><code>var</code></td><td>Global</td><td>✅ Yes</td></tr>
            <tr><td><code>let</code></td><td>Global</td><td>❌ No</td></tr>
            <tr><td><code>const</code></td><td>Global</td><td>❌ No</td></tr>
          </tbody>
        </table>
      
        <h3>💡 Tip</h3>
        <p>
          Prefer using <code>let</code> and <code>const</code> for better scope control and
          to avoid polluting the global object.
        </p>
    </section>            

    <section>
        <h2>11. 🔍 What is Hoisting in JavaScript?</h2>
      
        <p>
          <strong>Hoisting</strong> is JavaScript's default behavior of moving variable and function declarations
          to the top of their containing scope before code execution.
        </p>
      
        <h3>📌 Key Points</h3>
        <ul>
          <li>Only the declarations are hoisted, not the initializations.</li>
          <li>Function declarations are fully hoisted, allowing them to be invoked before they appear in the code.</li>
          <li>Variables declared with <code>var</code> are hoisted with an initial value of <code>undefined</code>.</li>
          <li>Variables declared with <code>let</code> or <code>const</code> are hoisted but reside in a <strong>temporal dead zone (TDZ)</strong> until their declaration is evaluated.</li>
        </ul>
      
        <h3>🧪 Examples</h3>
      
        <h4>Using <code>var</code></h4>
        <pre><code>// Example:
      console.log(a); // Output: undefined
      var a = 5;
      
      // Internally interpreted as:
      var a;
      console.log(a); // undefined
      a = 5;
        </code></pre>
      
        <h4>Using <code>let</code> or <code>const</code></h4>
        <pre><code>// Example with let:
      console.log(b); // ReferenceError: Cannot access 'b' before initialization
      let b = 10;
        </code></pre>
      
        <h4>Function Declarations vs. Function Expressions</h4>
        <pre><code>// Function Declaration (hoisted)
      greet(); // Works fine
      function greet() {
        console.log("Hello");
      }
      
      // Function Expression (hoisting applies to variable, not the function)
      sayHi(); // TypeError: sayHi is not a function
      var sayHi = function () {
        console.log("Hi");
      };
        </code></pre>
      
        <h3>💡 Summary Table</h3>
        <table border="1" cellpadding="8">
          <thead>
            <tr>
              <th>Type</th>
              <th>Hoisted?</th>
              <th>Accessible Before Declaration?</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>var</code></td>
              <td>Yes</td>
              <td>Yes (value is <code>undefined</code>)</td>
            </tr>
            <tr>
              <td><code>let</code> / <code>const</code></td>
              <td>Yes</td>
              <td>No (results in a TDZ error)</td>
            </tr>
            <tr>
              <td>Function Declaration</td>
              <td>Yes</td>
              <td>Yes</td>
            </tr>
            <tr>
              <td>Function Expression</td>
              <td>Yes (only the variable is hoisted)</td>
              <td>No (when used as a variable, it behaves like <code>var</code>)</td>
            </tr>
          </tbody>
        </table>
    </section>

    <section>
        <h2>12. 🧩 What are Default Parameters in JavaScript?</h2>
      
        <p>
          <strong>Default parameters</strong> allow you to specify default values for function parameters.
          If no argument is provided (or <code>undefined</code> is passed), the default value is used.
        </p>
      
        <h3>✅ Basic Example</h3>
        <pre><code>function greet(name = "Guest") {
        console.log("Hello, " + name);
      }
      
      greet("Alice");  // Output: Hello, Alice
      greet();         // Output: Hello, Guest</code></pre>
      
        <h3>📌 Use Cases</h3>
        <ul>
          <li>Providing fallback/default values</li>
          <li>Preventing <code>undefined</code> errors</li>
          <li>Making function calls simpler</li>
        </ul>
      
        <h3>❓ Default vs. <code>undefined</code></h3>
        <pre><code>function show(x = 100) {
        console.log(x);
      }
      
      show();           // 100 ✅
      show(undefined);  // 100 ✅
      show(null);       // null ❌
      show(0);          // 0 ❌</code></pre>
      
        <p>
          Only <code>undefined</code> triggers the default value — not <code>null</code> or other falsy values.
        </p>
      
        <h3>⚙️ Using Expressions as Defaults</h3>
        <pre><code>function calc(x = 1, y = x + 1) {
        console.log(x, y);
      }
      
      calc();      // 1 2
      calc(5);     // 5 6</code></pre>
      
        <h3>💡 Interview Tip</h3>
        <p>
          Default parameters help write cleaner and more resilient functions.
          Remember: defaults only apply when arguments are <code>undefined</code>!
        </p>
    </section>

    <section>
        <h2>13. 🧩 Explain Object Destructuring in JavaScript</h2>
      
        <p>
          <strong>Object destructuring</strong> is a syntax that lets you unpack properties from objects into distinct variables easily.
        </p>
      
        <h3>✅ Basic Example</h3>
        <pre><code>const user = {
        name: "Alice",
        age: 25,
        city: "Mumbai"
      };
      
      const { name, age } = user;
      
      console.log(name); // Alice
      console.log(age);  // 25
      </code></pre>
      
        <h3>🔄 Rename While Destructuring</h3>
        <pre><code>const { name: userName, city: userCity } = user;
      
      console.log(userName); // Alice
      console.log(userCity); // Mumbai
      </code></pre>
      
        <h3>💡 Default Values</h3>
        <pre><code>const { country = "India" } = user;
      
      console.log(country); // India
      </code></pre>
      
        <h3>📦 Nested Destructuring</h3>
        <pre><code>const person = {
        name: "Bob",
        address: {
          street: "Main Rd",
          city: "Delhi"
        }
      };
      
      const { address: { city } } = person;
      
      console.log(city); // Delhi
      </code></pre>
      
        <h3>✅ Destructuring in Function Parameters</h3>
        <pre><code>function greet({ name, age }) {
        console.log(`Hello ${name}, you are ${age} years old.`);
      }
      
      greet(user); // Hello Alice, you are 25 years old.
      </code></pre>
      
        <h3>⚠️ Common Mistake</h3>
        <pre><code>const { foo } = undefined; // ❌ TypeError
      </code></pre>
      
        <p>
          Always ensure you're not destructuring from <code>undefined</code> or <code>null</code>. Use optional chaining or default values to prevent errors.
        </p>
      
        <h3>📌 Tip</h3>
        <p>
          Object destructuring is clean, reduces code repetition, and is great for working with API data or component props in frameworks like React.
        </p>
    </section>
    
    <section>
        <h2>14. 💬 What Are Template Literals in JavaScript?</h2>
      
        <p>
          <strong>Template literals</strong> (also known as <em>template strings</em>) are a modern way to work with strings in JavaScript.
          They allow for:
        </p>
        <ul>
          <li>✅ String interpolation (inject variables/expressions into strings)</li>
          <li>✅ Multi-line strings</li>
          <li>✅ Expression evaluation inside strings</li>
        </ul>
      
        <p><strong>Syntax:</strong> Uses backticks <code>` `</code> instead of quotes.</p>
      
        <h3>✅ Example: String Interpolation</h3>
        <pre><code>const name = "Alice";
      const message = `Hello, ${name}!`;
      
      console.log(message); // Hello, Alice!
      </code></pre>
      
        <h3>📌 Multi-line Strings</h3>
        <pre><code>const poem = `Roses are red,
      Violets are blue,
      JavaScript is fun,
      And so are you!`;
      
      console.log(poem);
      </code></pre>
      
        <h3>🔢 Expression Evaluation</h3>
        <pre><code>const a = 5;
      const b = 10;
      const result = `Sum: ${a + b}`;
      
      console.log(result); // Sum: 15
      </code></pre>
      
        <h3>🛠️ Advanced: Tagged Templates</h3>
        <p>Use tag functions to customize template literal behavior:</p>
        <pre><code>function highlight(strings, value) {
        return `${strings[0]}***${value}***${strings[1]}`;
      }
      
      const lang = "JavaScript";
      const sentence = highlight`I love ${lang} very much!`;
      
      console.log(sentence); // I love ***JavaScript*** very much!
      </code></pre>
      
        <h3>💡 Interview Tip</h3>
        <p>
          Template literals are commonly used in frontend frameworks and for writing readable code.
          Mastering interpolation and multiline string usage is essential for modern JavaScript.
        </p>
    </section>      

    <section>
        <h2>15. ⚖️ What is the Ternary Operator in JavaScript?</h2>
      
        <p>
          The <strong>ternary operator</strong> is a concise way to perform conditional logic in JavaScript.
          It is often used as a shorthand for simple <code>if...else</code> statements.
        </p>
      
        <h3>✅ Syntax:</h3>
        <pre><code>condition ? expressionIfTrue : expressionIfFalse;
      </code></pre>
      
        <h3>📌 Basic Example:</h3>
        <pre><code>const age = 18;
      const result = age >= 18 ? "Adult" : "Minor";
      
      console.log(result); // Adult
      </code></pre>
      
        <h3>🔁 Nested Ternary Example (use with caution):</h3>
        <pre><code>const score = 85;
      const grade = score >= 90
        ? "A"
        : score >= 80
        ? "B"
        : score >= 70
        ? "C"
        : "F";
      
      console.log(grade); // B
      </code></pre>
      
        <p><strong>⚠️ Note:</strong> While ternary operators are great for concise code, nesting too many can make your code hard to read.</p>
      
        <h3>💡 Use Cases:</h3>
        <ul>
          <li>Quick conditional assignments</li>
          <li>Conditional rendering (e.g., in React JSX)</li>
          <li>Returning values based on simple checks</li>
        </ul>
      
        <h3>📘 Tip for Interviews:</h3>
        <p>
          Use ternary operators to simplify your logic, but always prioritize readability. It’s a great way to show you understand both logic and clean code.
        </p>
    </section>

    <section>
        <h2>16. 🧠 How Does JavaScript Manage Memory?</h2>
      
        <p>
          JavaScript manages memory automatically using a system called <strong>Garbage Collection (GC)</strong>.
          This system handles memory allocation when variables and objects are created, and frees memory when it’s no longer needed.
        </p>
      
        <h3>🔄 Memory Lifecycle in JavaScript</h3>
        <ol>
          <li><strong>Allocation</strong> – When a value is created and stored:
            <pre><code>let user = { name: "Alice" };</code></pre>
          </li>
          <li><strong>Use</strong> – The value is used in the program as long as it's referenced.</li>
          <li><strong>Release</strong> – If nothing references the value, it's eligible for garbage collection.</li>
        </ol>
      
        <h3>✅ Reachability</h3>
        <p>
          A value is <strong>reachable</strong> if it can be accessed or used in the program.
          Unreachable values are considered "garbage" and will be cleaned up by the garbage collector.
        </p>
        <pre><code>let a = {
        name: "Bob"
      };
      
      a = null; // object becomes unreachable → memory is freed
      </code></pre>
      
        <h3>🔁 Mark-and-Sweep Algorithm</h3>
        <p>
          Modern JavaScript engines (like V8) use this algorithm:
        </p>
        <ul>
          <li>🔹 Mark all <strong>reachable</strong> objects starting from root (e.g., global variables)</li>
          <li>🔹 <strong>Sweep</strong> and remove all unmarked (unreachable) objects from memory</li>
        </ul>
      
        <h3>💡 Best Practices to Avoid Memory Leaks</h3>
        <ul>
          <li>❌ Avoid unnecessary global variables</li>
          <li>🔄 Remove event listeners when not needed</li>
          <li>🕓 Clear timeouts and intervals using <code>clearTimeout</code> and <code>clearInterval</code></li>
          <li>♻️ Break circular references</li>
        </ul>
      
        <h3>⚠️ Common Sources of Memory Leaks</h3>
        <ul>
          <li>Uncleared timers or intervals</li>
          <li>Closures holding unused variables</li>
          <li>DOM elements removed from page but still referenced in JS</li>
          <li>Large caches without limits</li>
        </ul>
      
        <h3>📘 Interview Tip</h3>
        <p>
          Understanding how JavaScript manages memory shows depth in handling performance and debugging memory issues.
          Use this knowledge to write efficient and clean applications.
        </p>
    </section>

    <section>
        <h2>17. 🧠 How Does Lexical Scoping Work in JavaScript?</h2>
      
        <p>
          <strong>Lexical scoping</strong> means that the scope of variables is determined by the <em>physical location</em> of the code when it is written, not when it is executed.
          In JavaScript, functions are <strong>lexically scoped</strong>, so a function can access variables defined in its outer scope.
        </p>
      
        <h3>📦 Example:</h3>
        <pre><code>     function outer() {
        let a = 10;
      
        function inner() {
          console.log(a); // ✅ accessible due to lexical scope
        }
      
        inner();
      }
      
      outer();
      </code></pre>
      
        <p>✅ <code>inner()</code> can access <code>a</code> because it's written inside <code>outer()</code>.</p>
      
        <h3>❌ Accessing Outer Scope from Outside</h3>
        <pre><code>      function outer() {
        let x = 100;
      }
      
      function another() {
        console.log(x); // ❌ ReferenceError: x is not defined
      }
      
      another();
      </code></pre>
      
        <p>❗ <code>x</code> is not available in <code>another()</code> because <code>another</code> is not lexically inside <code>outer</code>.</p>
      
        <h3>📚 Lexical vs Dynamic Scope</h3>
        <table border="1" cellpadding="6">
          <tr>
            <th>Feature</th>
            <th>Lexical Scope</th>
            <th>Dynamic Scope</th>
          </tr>
          <tr>
            <td>Scope Determined By</td>
            <td>Where code is written</td>
            <td>Where function is called</td>
          </tr>
          <tr>
            <td>Supported in JavaScript?</td>
            <td>✅ Yes</td>
            <td>❌ No</td>
          </tr>
        </table>
      
        <h3>🔁 Closures & Lexical Scope</h3>
        <pre><code>     function outer() {
        let counter = 0;
      
        return function inner() {
          counter++;
          console.log(counter);
        };
      }
      
      const increment = outer();
      increment(); // 1
      increment(); // 2
      </code></pre>
      
        <p>
          Here, <code>inner()</code> "remembers" <code>counter</code> from its outer scope. This is possible due to <strong>lexical scoping</strong> and <strong>closures</strong>.
        </p>
      
        <h3>💡 Interview Tip</h3>
        <p>
          Lexical scoping is a core concept that underpins closures and variable visibility. Understand it deeply to debug and write modular JavaScript code effectively.
        </p>
    </section>    

    <section>
        <h2>18. 🔁 What is a Return Value in JavaScript?</h2>
      
        <p>
          A <strong>return value</strong> is the value a function gives back to the code that called it.
          It is specified using the <code>return</code> statement inside the function.
        </p>
      
        <h3>✅ Example:</h3>
        <pre><code>function add(a, b) {
        return a + b;
      }
      
      const result = add(3, 4); // result = 7
      </code></pre>
      
        <ul>
          <li><code>return</code> ends the function and sends the value back.</li>
          <li>After <code>return</code> runs, no further code in the function executes.</li>
        </ul>
      
        <h3>⚠️ If You Don't Return:</h3>
        <pre><code>function sayHello() {
        console.log("Hello");
      }
      
      const output = sayHello(); // Output: "Hello"
      console.log(output); // undefined
      </code></pre>
      
        <p>If a function has no <code>return</code>, it returns <strong>undefined</strong> by default.</p>
      
        <h3>📦 Use Cases of Return Values:</h3>
        <ul>
          <li>Store results in variables</li>
          <li>Use the output in another function</li>
          <li>Make decisions based on returned value</li>
        </ul>
      
        <h3>💡 Tip:</h3>
        <p>
          Functions can return any type of value: numbers, strings, arrays, objects, even other functions. Use return values to keep code clean and functional.
        </p>
    </section>   
    
    <section>
      <h2>19. 🔁 Callback Functions in JavaScript</h2>
    
      <p>
        In JavaScript, functions are <strong>first-class citizens</strong>. This means functions can be:
        <ul>
          <li>Stored in variables</li>
          <li>Passed as arguments to other functions</li>
          <li>Returned from other functions</li>
        </ul>
      </p>
    
      <p>
        When we pass a function as an argument to another function, the passed function is called a <strong>callback function</strong>.
      </p>
    
      <h3>🔸 Example:</h3>
      <pre><code>    function x(y) {
      console.log("x");
      y();
    }
    
    x(function y() {
      console.log("y");
    });
    </code></pre>
      <p>
        In the above example:
        <ul>
          <li><code>function y()</code> is passed to <code>function x()</code></li>
          <li><code>y()</code> is called inside <code>x()</code></li>
          <li>Hence, <code>y</code> is a <strong>callback function</strong></li>
        </ul>
      </p>
    
      <h3>🔸 Another Example (with setTimeout):</h3>
      <pre><code>    setTimeout(function a() {
      console.log("Hi");
    }, 5000);</code></pre>
    
      <p>
        Here, <code>function a()</code> is a callback function passed to <code>setTimeout()</code>.
      </p>
    
      <h3>💡 Why are callbacks important?</h3>
      <p>
        JavaScript is a <strong>synchronous, single-threaded language</strong>—it executes one command at a time, in order.
        But using <strong>callbacks</strong>, we can handle <strong>asynchronous operations</strong> like network calls, timers, etc.
      </p>
      <p>
        If a function takes a long time to execute (e.g., 20–30 seconds), running it on the main thread would block the entire JavaScript environment.
        This is where callbacks help—they allow us to delay execution or run tasks asynchronously, preventing the UI and main thread from being blocked.
      </p>
    
      <h3>✅ Summary:</h3>
      <ul>
        <li>A callback function is passed as an argument to another function.</li>
        <li>The function receiving the callback decides when to invoke it.</li>
        <li>Callbacks enable asynchronous behavior in JavaScript.</li>
        <li>They are essential for time-consuming operations like API calls, file reading, etc.</li>
      </ul>
    </section>
    
    <section>
      <h2>20.🙈 Anonymous Functions in JavaScript</h2>
    
      <p>
        An <strong>anonymous function</strong> is a function that does <strong>not have a name</strong>. These functions are often used in situations where a function is used only once or passed as an argument to another function.
      </p>
    
      <h3>🔸 Syntax:</h3>
      <pre><code>    function () {
      console.log("This is an anonymous function");
    }</code></pre>
      <p><strong>Note:</strong> The above code will throw an error if used standalone, because it must be assigned to a variable or passed directly where a function is expected.</p>
    
      <h3>🔸 Example (assigned to a variable):</h3>
      <pre><code>    const greet = function () {
      console.log("Hello!");
    };
    
    greet();</code></pre>
    
      <h3>🔸 Example (used as a callback):</h3>
      <pre><code>    setTimeout(function () {
      console.log("Executed after 2 seconds");
    }, 2000);</code></pre>
    
      <h3>✅ Use Cases:</h3>
      <ul>
        <li>Used when the function is needed only temporarily</li>
        <li>Common in callbacks, event handlers, and IIFE (Immediately Invoked Function Expressions)</li>
        <li>Improves code brevity and encapsulation</li>
      </ul>
    
      <h3>⚠️ Things to Note:</h3>
      <ul>
        <li>Anonymous functions cannot reference themselves unless assigned to a variable</li>
        <li>They are useful in functional-style programming</li>
      </ul>
    </section>    
    
    <section>
      <h2>21.🔼 Higher-Order Functions in JavaScript</h2>
    
      <p>
        A <strong>Higher-Order Function (HOF)</strong> is a function that either:
        <ul>
          <li>Accepts another function as an argument</li>
          <li>Returns a function</li>
          <li>Or does both</li>
        </ul>
      </p>
    
      <p>
        Since functions are first-class citizens in JavaScript, we can pass them around like values, enabling us to write powerful abstractions.
      </p>
    
      <h3>🔸 Example 1: Passing a function as an argument</h3>
      <pre><code>function greet(name) {
      return "Hello " + name;
    }
    
    function higherOrderFunction(callback) {
      console.log(callback("Pratik"));
    }
    
    higherOrderFunction(greet);</code></pre>
    
      <h3>🔸 Example 2: Returning a function</h3>
      <pre><code>function multiplier(factor) {
      return function(number) {
        return number * factor;
      };
    }
    
    const double = multiplier(2);
    console.log(double(5)); // Output: 10</code></pre>
    
      <h3>🔸 Example 3: Common use case — Array methods</h3>
      <pre><code>const numbers = [1, 2, 3, 4, 5];
    
    const squared = numbers.map(function(num) {
      return num * num;
    });
    
    console.log(squared); // [1, 4, 9, 16, 25]</code></pre>
    
      <h3>✅ Summary:</h3>
      <ul>
        <li>Higher-order functions abstract logic with functions.</li>
        <li>Enable reusable and modular code.</li>
        <li>Examples include: <code>map()</code>, <code>filter()</code>, <code>reduce()</code>, <code>setTimeout()</code>, etc.</li>
      </ul>
    </section>      
    
    <section> 
      <h2>22. ➡️ Arrow Functions in JavaScript</h2>
    
      <p>
        <strong>Arrow functions</strong> are a shorter syntax for writing function expressions in JavaScript, introduced in ES6.
        They are often used for concise function expressions and have a special behavior with the <code>this</code> keyword.
      </p>
    
      <h3>🔸 Syntax:</h3>
      <pre><code>// Traditional Function Expression
    const add = function(a, b) {
      return a + b;
    };
    
    // Arrow Function Equivalent
    const add = (a, b) => a + b;</code></pre>
    
      <h3>🔸 Features of Arrow Functions:</h3>
      <ul>
        <li>Shorter syntax</li>
        <li><strong>No binding of <code>this</code></strong> — it uses the <code>this</code> value from the enclosing lexical context</li>
        <li>Cannot be used as constructors</li>
        <li>Do not have <code>arguments</code> object</li>
        <li>Cannot use <code>new.target</code></li>
      </ul>
    
      <h3>🔸 Example: Basic Arrow Function</h3>
      <pre><code>const greet = name => "Hello, " + name;
    
    console.log(greet("Pratik")); // Output: Hello, Pratik</code></pre>
    
      <h3>🔸 Example: Arrow Function with <code>this</code></h3>
      <pre><code>function Timer() {
      this.seconds = 0;
      setInterval(() => {
        this.seconds++;
        console.log(this.seconds);
      }, 1000);
    }
    
    new Timer();</code></pre>
      <p>
        In the example above, arrow function preserves the <code>this</code> context from the <code>Timer</code> function.
      </p>
    
      <h3>✅ Summary:</h3>
      <ul>
        <li>Arrow functions are concise and great for short callbacks.</li>
        <li>They inherit <code>this</code> from the parent scope (lexical scoping).</li>
        <li>Best suited for non-method functions, especially callbacks.</li>
      </ul>
    </section>

    <section>
      <h2>23. 🔒 Closures in JavaScript</h2>
    
      <p>
        A <strong>closure</strong> is a feature in JavaScript where an inner function has access to variables from its outer (enclosing) function scope, even after the outer function has finished executing.
      </p>
    
      <h3>🔸 A Closure has access to:</h3>
      <ul>
        <li>Its own scope</li>
        <li>The outer function’s variables</li>
        <li>The global scope</li>
      </ul>
    
      <h3>🔸 Example:</h3>
      <pre><code>function outerFunction() {
      let outerVariable = "I am outside!";
    
      function innerFunction() {
        console.log(outerVariable); // Accessing outer variable
      }
    
      return innerFunction;
    }
    
    const myClosure = outerFunction();
    myClosure(); // Output: "I am outside!"</code></pre>
    
      <p>
        In this example, <code>innerFunction</code> retains access to <code>outerVariable</code> even after <code>outerFunction</code> has returned. That’s what makes it a closure.
      </p>
    
      <h3>🔸 Real-life Use Cases:</h3>
      <ul>
        <li>Data privacy (like creating private variables)</li>
        <li>Function factories</li>
        <li>Event handlers</li>
        <li>Callback functions and async programming</li>
      </ul>
    
      <h3>🔸 Closure for Data Privacy:</h3>
      <pre><code>function counter() {
      let count = 0;
    
      return function () {
        count++;
        console.log(count);
      };
    }
    
    const increment = counter();
    increment(); // 1
    increment(); // 2
    increment(); // 3</code></pre>
    
      <h3>✅ Summary:</h3>
      <ul>
        <li>A closure "closes over" its lexical environment.</li>
        <li>Allows inner functions to access outer function variables after the outer function has finished execution.</li>
        <li>Powerful for building encapsulated and modular code.</li>
      </ul>
    </section>   

    <section>
      <h2>23.📦 When and Why Would You Use Closures?</h2>
    
      <p>
        <strong>Closures</strong> are useful when you need to:
      </p>
    
      <h3>🔸 1. Data Encapsulation and Privacy</h3>
      <p>
        You can create private variables that are not accessible from outside the function.
      </p>
      <pre><code>    function secretCounter() {
      let count = 0;
    
      return function() {
        count++;
        console.log(count);
      };
    }
    
    const counter = secretCounter();
    counter(); // 1
    counter(); // 2
    // No way to access or modify `count` directly</code></pre>
    
      <h3>🔸 2. Function Factories</h3>
      <p>
        Closures let you create functions that are pre-configured with specific data.
      </p>
      <pre><code>    function multiplier(factor) {
      return function(number) {
        return number * factor;
      };
    }
    
    const double = multiplier(2);
    console.log(double(5)); // 10</code></pre>
    
      <h3>🔸 3. Maintaining State Between Function Calls</h3>
      <p>
        Use closures to preserve state across multiple invocations.
      </p>
      <pre><code>    function rememberName(name) {
      return function() {
        console.log("Remembered name:", name);
      };
    }
    
    const sayName = rememberName("Pratik");
    sayName(); // "Remembered name: Pratik"</code></pre>
    
      <h3>🔸 4. Asynchronous Code & Event Handlers</h3>
      <p>
        Closures help in preserving variables in async operations or inside loops.
      </p>
      <pre><code>    for (var i = 0; i < 3; i++) {
      setTimeout(function() {
        console.log(i); // Prints 3 three times
      }, 1000);
    }
    
    // Using closure to fix the issue
    for (var i = 0; i < 3; i++) {
      (function(j) {
        setTimeout(function() {
          console.log(j); // Prints 0, 1, 2
        }, 1000);
      })(i);
    }</code></pre>
    
      <h3>✅ Summary:</h3>
      <ul>
        <li>Use closures when you want to retain access to a function’s scope after it has executed.</li>
        <li>They’re powerful for private variables, creating configurable functions, and writing clean async logic.</li>
        <li>Closures improve modularity and maintainability in your code.</li>
      </ul>
    </section>
    
    <section>
      <h2>24.🍛 What is Function Currying?</h2>
    
      <p>
        <strong>Currying</strong> is a functional programming technique in JavaScript where a function is transformed into a sequence of functions, each taking a single argument.
      </p>
    
      <p>
        Instead of taking all arguments at once, a curried function takes the first argument and returns a new function that takes the second, and so on.
      </p>
    
      <h3>🔸 Example: Without Currying</h3>
      <pre><code>    function sum(a, b, c) {
      return a + b + c;
    }
    
    console.log(sum(1, 2, 3)); // 6</code></pre>
    
      <h3>🔸 Example: With Currying</h3>
      <pre><code>    function curriedSum(a) {
      return function(b) {
        return function(c) {
          return a + b + c;
        };
      };
    }
    
    console.log(curriedSum(1)(2)(3)); // 6</code></pre>
    
      <h3>🔸 Why Use Currying?</h3>
      <ul>
        <li>Helps in creating <strong>reusable functions</strong></li>
        <li>Great for <strong>function composition</strong> and cleaner code</li>
        <li>Useful in partial application of arguments</li>
        <li>Makes functions more <strong>pure</strong> and easier to test</li>
      </ul>
    
      <h3>🔸 Example: Practical Usage</h3>
      <pre><code>    function greet(greeting) {
      return function(name) {
        return greeting + ", " + name + "!";
      };
    }
    
    const sayHello = greet("Hello");
    console.log(sayHello("Pratik")); // Hello, Pratik!</code></pre>
    
      <h3>✅ Summary:</h3>
      <ul>
        <li>Currying breaks down a function that takes multiple arguments into a series of unary (single-argument) functions.</li>
        <li>It allows us to <strong>preset arguments</strong> and write more readable and reusable code.</li>
        <li>Common in functional programming and libraries like Lodash and Ramda.</li>
      </ul>
    </section>    

    <section id="call-apply-bind">
      <h2>25. Call, Apply, and Bind in JavaScript</h2>
    
      <p>In JavaScript, <code>call()</code>, <code>apply()</code>, and <code>bind()</code> are used to set the <code>this</code> context explicitly.</p>
    
      <h3>1. call()</h3>
      <p>
        The <code>call()</code> method calls a function with a given <code>this</code> value and arguments provided individually.
      </p>
      <pre><code>
    function greet(name, age) {
      console.log(`Hi, I'm ${name} and I'm ${age} years old.`);
    }
    
    greet.call(null, "Pratik", 25); 
    // Output: Hi, I'm Pratik and I'm 25 years old.
      </code></pre>
      <p><strong>Note:</strong> We passed <code>null</code> as the first argument because the function does not use <code>this</code>.</p>
    
      <h3>2. apply()</h3>
      <p>
        The <code>apply()</code> method is similar to <code>call()</code>, but it takes arguments as an array.
      </p>
      <pre><code>
    const args = ["Pratik", 25];
    greet.apply(null, args); 
    // Output: Hi, I'm Pratik and I'm 25 years old.
      </code></pre>
      <p><strong>Use Case:</strong> When arguments are already in an array.</p>
    
      <h3>3. bind()</h3>
      <p>
        The <code>bind()</code> method returns a new function with a specified <code>this</code> value and optional initial arguments.
        It does <strong>not</strong> call the function immediately.
      </p>
      <pre><code>
    const person = {
      name: "Ravi",
      greet: function(age) {
        console.log(`Hello, I'm ${this.name} and I'm ${age} years old.`);
      }
    };
    
    const greetRavi = person.greet.bind(person);
    greetRavi(35); 
    // Output: Hello, I'm Ravi and I'm 35 years old.
      </code></pre>
    
      <h3>📊 Summary Table</h3>
      <table border="1" cellpadding="5" cellspacing="0">
        <thead>
          <tr>
            <th>Method</th>
            <th>Called Immediately?</th>
            <th>Arguments Format</th>
            <th>Returns a Function?</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>call()</code></td>
            <td>Yes</td>
            <td>Individual arguments</td>
            <td>No</td>
          </tr>
          <tr>
            <td><code>apply()</code></td>
            <td>Yes</td>
            <td>Array of arguments</td>
            <td>No</td>
          </tr>
          <tr>
            <td><code>bind()</code></td>
            <td>No</td>
            <td>Individual arguments (optional)</td>
            <td>Yes</td>
          </tr>
        </tbody>
      </table>
    
      <h3>✅ When to Use</h3>
      <ul>
        <li><strong>call()</strong>: When arguments are separate.</li>
        <li><strong>apply()</strong>: When arguments are in an array.</li>
        <li><strong>bind()</strong>: When you want to fix <code>this</code> and call the function later.</li>
      </ul>
    </section>   

    <section id="custom-bind">
      <h2>26. Custom Implementation of bind()</h2>
    
      <p>Here's how you can implement your own version of <code>bind()</code>:</p>
    
      <pre><code>
    Function.prototype.myBind = function(context, ...args1) {
      const originalFunc = this;
      return function(...args2) {
        return originalFunc.apply(context, [...args1, ...args2]);
      };
    };
      </code></pre>
    
      <h3>Example:</h3>
      <pre><code>
    const person = {
      name: "Pratik"
    };
    
    function greet(greeting, punctuation) {
      console.log(`${greeting}, I'm ${this.name}${punctuation}`);
    }
    
    const greetPerson = greet.myBind(person, "Hello");
    greetPerson("!");
    // Output: Hello, I'm Pratik!
      </code></pre>
    
      <h3>Explanation:</h3>
      <ul>
        <li><strong>context:</strong> The object you want <code>this</code> to refer to.</li>
        <li><strong>args1:</strong> Arguments passed when binding.</li>
        <li><strong>args2:</strong> Arguments passed when the new function is called.</li>
        <li><strong>apply:</strong> Used to call the original function with combined arguments.</li>
      </ul>
    </section>

    <section id="objects-and-arrays">
      <h2>27. Creating Objects and Arrays in JavaScript</h2>
    
      <h3>Creating Objects</h3>
      <h4>1. Object Literal</h4>
      <pre><code>
    const person = {
      name: "Pratik",
      age: 25,
      greet: function () {
        console.log("Hello!");
      }
    };
      </code></pre>
    
      <h4>2. new Object()</h4>
      <pre><code>
    const person = new Object();
    person.name = "Pratik";
    person.age = 25;
      </code></pre>
    
      <h4>3. Constructor Function</h4>
      <pre><code>
    function Person(name, age) {
      this.name = name;
      this.age = age;
    }
    const person1 = new Person("Pratik", 25);
      </code></pre>
    
      <h4>4. Object.create()</h4>
      <pre><code>
    const proto = {
      greet() {
        console.log("Hi, I'm " + this.name);
      }
    };
    const person = Object.create(proto);
    person.name = "Pratik";
      </code></pre>
    
      <h3>Creating Arrays</h3>
      <h4>1. Array Literal</h4>
      <pre><code>
    const fruits = ["Apple", "Banana", "Mango"];
      </code></pre>
    
      <h4>2. new Array()</h4>
      <pre><code>
    const fruits = new Array("Apple", "Banana", "Mango");
      </code></pre>
    
      <h4>3. Empty Array</h4>
      <pre><code>
    const numbers = [];
    numbers[0] = 10;
    numbers[1] = 20;
      </code></pre>
    </section>   
    
    <section id="accessing-properties">
      <h2>28. Accessing Object Properties in JavaScript</h2>
    
      <h3>1. Dot Notation</h3>
      <p>Use when the property name is a valid identifier.</p>
      <pre><code>
    const person = {
      name: "Pratik",
      age: 25
    };
    
    console.log(person.name); // "Pratik"
    console.log(person.age);  // 25
      </code></pre>
    
      <h3>2. Bracket Notation</h3>
      <p>Use when the property name is dynamic or contains spaces/special characters.</p>
      <pre><code>
    const person = {
      name: "Pratik",
      "home city": "Mumbai"
    };
    
    console.log(person["name"]);        // "Pratik"
    console.log(person["home city"]);   // "Mumbai"
    
    const key = "name";
    console.log(person[key]);           // "Pratik"
      </code></pre>
    
      <h3>Common Pitfall</h3>
      <pre><code>
    const obj = { key: "value" };
    
    console.log(obj.key);    // "value"
    console.log(obj["key"]); // "value"
    console.log(obj[key]);   // ReferenceError if 'key' not defined
      </code></pre>
    </section>

    <section id="map-filter-reduce-foreach">
      <h2>29. JavaScript Array Methods</h2>
    
      <h3>1. map()</h3>
      <p>Creates a new array by transforming each element.</p>
      <pre><code>
    const nums = [1, 2, 3, 4];
    const squared = nums.map(num => num * num);
    console.log(squared); // [1, 4, 9, 16]
      </code></pre>
    
      <h3>2. filter()</h3>
      <p>Filters elements based on a condition.</p>
      <pre><code>
    const nums = [1, 2, 3, 4, 5];
    const even = nums.filter(num => num % 2 === 0);
    console.log(even); // [2, 4]
      </code></pre>
    
      <h3>3. reduce()</h3>
      <p>Reduces an array to a single value.</p>
      <pre><code>
    const nums = [1, 2, 3, 4];
    const sum = nums.reduce((acc, curr) => acc + curr, 0);
    console.log(sum); // 10
      </code></pre>
    
      <h3>4. forEach()</h3>
      <p>Runs a function on each element (no return value).</p>
      <pre><code>
    const nums = [1, 2, 3];
    nums.forEach(num => console.log(num * 2));
    // Logs: 2, 4, 6
      </code></pre>
    </section>  
    
    <section id="spread-operator">
      <h2>30. Spread Operator in JavaScript</h2>
    
      <p>The spread operator (<code>...</code>) is used to expand elements of an array or object.</p>
    
      <h3>1. Spreading in Arrays</h3>
      <pre><code>
    const arr1 = [1, 2, 3];
    const arr2 = [4, 5];
    const combined = [...arr1, ...arr2];
    console.log(combined); // [1, 2, 3, 4, 5]
      </code></pre>
    
      <h3>2. Copying Arrays</h3>
      <pre><code>
    const original = [10, 20, 30];
    const copy = [...original];
    console.log(copy); // [10, 20, 30]
      </code></pre>
    
      <h3>3. Spreading in Objects</h3>
      <pre><code>
    const obj1 = { a: 1, b: 2 };
    const obj2 = { c: 3 };
    const merged = { ...obj1, ...obj2 };
    console.log(merged); // { a: 1, b: 2, c: 3 }
      </code></pre>
    
      <h3>4. Function Arguments</h3>
      <pre><code>
    function sum(a, b, c) {
      return a + b + c;
    }
    const numbers = [1, 2, 3];
    console.log(sum(...numbers)); // 6
      </code></pre>
    </section>    
    
    <section id="merging-objects">
      <h2>31.🔄 Merging Objects in JavaScript</h2>
    
      <h3>1. Using Spread Operator</h3>
      <pre><code>
    const obj1 = { name: "Pratik", age: 25 };
    const obj2 = { city: "Mumbai" };
    const merged = { ...obj1, ...obj2 };
    console.log(merged);
    // Output: { name: "Pratik", age: 25, city: "Mumbai" }
      </code></pre>
    
      <h3>2. Using Object.assign()</h3>
      <pre><code>
    const merged = Object.assign({}, obj1, obj2);
      </code></pre>
    
      <h3>3. Merging More Than Two Objects</h3>
      <pre><code>
    const final = { ...obj1, ...obj2, ...obj3 };
      </code></pre>
    
      <h3>4. Deep Merging with Lodash</h3>
      <pre><code>
    const merged = _.merge({}, obj1, obj2);
      </code></pre>
    </section>  
    
    <section id="cloning">
      <h2>32.🔁 Deep vs Shallow Cloning</h2>
    
      <h3>🟡 Shallow Clone</h3>
      <pre><code>
    const user = {
      name: "Pratik",
      address: { city: "Mumbai" }
    };
    
    const shallow = { ...user };
    shallow.address.city = "Pune";
    
    console.log(user.address.city); // "Pune" ❌ Affected!
      </code></pre>
    
      <h3>🟢 Deep Clone (JSON method)</h3>
      <pre><code>
    const deep = JSON.parse(JSON.stringify(user));
    deep.address.city = "Delhi";
    
    console.log(user.address.city); // "Mumbai" ✅ Safe
      </code></pre>
    
      <h3>✅ structuredClone() (Modern)</h3>
      <pre><code>
    const clone = structuredClone(user);
      </code></pre>
    
      <h3>🔧 Lodash Method</h3>
      <pre><code>
    const _ = require('lodash');
    const clone = _.cloneDeep(user);
      </code></pre>
    </section>        

    <section id="flatten-nested-arrays">
      <h2>33. 🔁 Flatten Nested Arrays</h2>
    
      <p>Flattening means converting nested arrays into a single-level array.</p>
    
      <h3>✅ Using flat()</h3>
      <pre><code>
    const arr = [1, 2, [3, 4, [5, 6]], 7];
    const flat = arr.flat(2);
    console.log(flat); // [1, 2, 3, 4, 5, 6, 7]
      </code></pre>
    
      <h3>✅ Using flat(Infinity)</h3>
      <pre><code>
    const nested = [1, [2, [3, [4]]]];
    const flat = nested.flat(Infinity);
    console.log(flat); // [1, 2, 3, 4]
      </code></pre>
    
      <h3>✅ Using Recursion</h3>
      <pre><code>
    function flatten(arr) {
      return arr.reduce((acc, val) =>
        Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val), []);
    }
      </code></pre>
    </section>

    <section id="array-object-methods">
      <h2>34. JavaScript Array & Object Methods</h2>
    
      <h3>🟦 Array Methods</h3>
    
      <h4>✅ Iteration & Transformation</h4>
      <ul>
        <li><code>forEach()</code> – Executes a function on each array element</li>
        <li><code>map()</code> – Transforms each element, returns a new array</li>
        <li><code>filter()</code> – Filters elements based on condition</li>
        <li><code>reduce()</code> – Reduces array to a single value</li>
        <li><code>some()</code> – Checks if any element matches condition</li>
        <li><code>every()</code> – Checks if all elements match condition</li>
        <li><code>find()</code> – Finds the first matching element</li>
        <li><code>findIndex()</code> – Finds index of first match</li>
      </ul>
    
      <h4>✅ Modification</h4>
      <ul>
        <li><code>push()</code> – Adds element to end</li>
        <li><code>pop()</code> – Removes last element</li>
        <li><code>shift()</code> – Removes first element</li>
        <li><code>unshift()</code> – Adds element to beginning</li>
        <li><code>splice()</code> – Adds/removes elements at a specific index</li>
        <li><code>slice()</code> – Returns a shallow copy of portion</li>
        <li><code>concat()</code> – Merges arrays</li>
        <li><code>fill()</code> – Fills array with a value</li>
        <li><code>reverse()</code> – Reverses array order</li>
        <li><code>sort()</code> – Sorts array</li>
        <li><code>flat()</code> – Flattens nested arrays</li>
        <li><code>includes()</code> – Checks if array contains element</li>
        <li><code>indexOf()</code> – Returns index of element</li>
        <li><code>join()</code> – Joins array into string</li>
      </ul>
    
      <h3>🟨 Object Methods</h3>
    
      <h4>✅ Inspection</h4>
      <ul>
        <li><code>Object.keys()</code> – Returns keys as array</li>
        <li><code>Object.values()</code> – Returns values as array</li>
        <li><code>Object.entries()</code> – Returns key-value pairs</li>
        <li><code>hasOwnProperty()</code> – Checks if key exists on object</li>
      </ul>
    
      <h4>✅ Copying & Cloning</h4>
      <ul>
        <li><code>Object.assign()</code> – Copies properties</li>
        <li><code>structuredClone()</code> – Deep copy (modern)</li>
        <li><code>JSON.parse(JSON.stringify(obj))</code> – Deep clone (legacy)</li>
      </ul>
    
      <h4>✅ Other Useful Ones</h4>
      <ul>
        <li><code>Object.create(proto)</code> – Create object with prototype</li>
        <li><code>Object.freeze()</code> – Make object immutable</li>
        <li><code>Object.seal()</code> – Prevent add/delete properties</li>
        <li><code>delete obj.prop</code> – Remove a property</li>
      </ul>
    
      <h4>🔍 Examples</h4>
      <pre><code>
    const nums = [1, 2, 3];
    const doubled = nums.map(n => n * 2); // [2, 4, 6]
    
    const user = { name: "Pratik", age: 25 };
    console.log(Object.keys(user)); // ['name', 'age']
      </code></pre>
    </section>
    
    <section id="js-methods">
      <h2>35.🧠 JavaScript Array & Object Methods – Examples</h2>
    
      <h3>🔧 splice()</h3>
      <p><strong>Used to add/remove elements at any position in the array. It mutates the original array.</strong></p>
      <pre><code>
    const arr = [1, 2, 3, 4, 5];
    arr.splice(2, 1); // Remove 1 item at index 2
    // [1, 2, 4, 5]
    
    arr.splice(1, 0, 100); // Insert 100 at index 1
    // [1, 100, 2, 4, 5]
      </code></pre>
    
      <h3>🧩 slice()</h3>
      <p><strong>Returns a shallow copy of a portion of an array. Does NOT modify original array.</strong></p>
      <pre><code>
    const arr = [10, 20, 30, 40, 50];
    const sliced = arr.slice(1, 4);
    // [20, 30, 40]
      </code></pre>
    
      <h3>➕ concat()</h3>
      <p><strong>Used to merge two or more arrays into a new one.</strong></p>
      <pre><code>
    const a = [1, 2];
    const b = [3, 4];
    const merged = a.concat(b, [5, 6]);
    // [1, 2, 3, 4, 5, 6]
      </code></pre>
    
      <h3>🧯 fill()</h3>
      <p><strong>Fills elements in an array with a static value.</strong></p>
      <pre><code>
    const filled = new Array(5).fill(0);
    // [0, 0, 0, 0, 0]
    
    const arr = [1, 2, 3, 4, 5];
    arr.fill(9, 1, 4);
    // [1, 9, 9, 9, 5]
      </code></pre>
    
      <h3>🔒 Object.seal()</h3>
      <p><strong>Prevents adding or removing properties, but allows updating existing ones.</strong></p>
      <pre><code>
    const person = {
      name: "Pratik",
      age: 25
    };
    
    Object.seal(person);
    person.age = 30; // Allowed
    person.city = "Mumbai"; // Not added
    delete person.name; // Not allowed
    
    // { name: "Pratik", age: 30 }
      </code></pre>
    
      <h3>❌ delete obj.prop</h3>
      <p><strong>Removes a property from an object.</strong></p>
      <pre><code>
    const obj = {
      name: "Pratik",
      age: 25
    };
    
    delete obj.age;
    // { name: "Pratik" }
      </code></pre>
    </section>
        
    <section id="async-programming">
      <h2>36.⚙️ What is Asynchronous Programming in JavaScript?</h2>
    
      <p>Asynchronous programming allows JavaScript to perform non-blocking operations. It enables the code to continue executing while waiting for longer tasks like API calls, timers, or file operations to complete.</p>
    
      <h3>🔄 Synchronous vs Asynchronous</h3>
      <h4>🕰 Synchronous Example</h4>
      <pre><code>
    console.log("Start");
    alert("This takes time...");
    console.log("End");
      </code></pre>
    
      <h4>🔁 Asynchronous Example</h4>
      <pre><code>
    console.log("Start");
    setTimeout(() => {
      console.log("Inside setTimeout");
    }, 2000);
    console.log("End");
      </code></pre>
    
      <p><strong>Output:</strong></p>
      <pre><code>
    Start
    End
    Inside setTimeout
      </code></pre>
    
      <h3>🛠 Common Async Tools</h3>
      <ul>
        <li>setTimeout, setInterval</li>
        <li>Promises</li>
        <li>async/await</li>
        <li>Event listeners</li>
        <li>Fetch API</li>
      </ul>
    
      <h3>✅ Benefits of Asynchronous Code</h3>
      <ul>
        <li>Non-blocking execution</li>
        <li>Better performance</li>
        <li>Improved user experience</li>
        <li>Essential for I/O tasks and API calls</li>
      </ul>
    </section>   
    
    <section style="font-family: Arial, sans-serif; background: #f7faff; padding: 20px; border-radius: 10px;">
      <h2 style="color: #2c3e50;">🔐 37. Promises in JavaScript (Based on Akshay Saini - Namaste JavaScript)</h2>
    
      <p><strong>Definition:</strong> A <em>Promise</em> is an object that represents the <strong>eventual success or failure</strong> of an asynchronous operation.</p>
    
      <h3 style="color: #34495e;">✅ Why Promises?</h3>
      <ul>
        <li>JavaScript is single-threaded and synchronous by default.</li>
        <li>Callbacks were used earlier for async tasks but led to <strong>callback hell</strong> and <strong>inversion of control</strong>.</li>
        <li>Promises solve this problem by providing a cleaner syntax and control over async flow.</li>
      </ul>
    
      <h3 style="color: #34495e;">📌 Promise States</h3>
      <ul>
        <li><strong>Pending:</strong> Initial state, not resolved or rejected.</li>
        <li><strong>Fulfilled:</strong> The operation completed successfully.</li>
        <li><strong>Rejected:</strong> The operation failed.</li>
      </ul>
    
      <h3 style="color: #34495e;">🛠️ Creating a Promise</h3>
      <pre style="background: #eef; padding: 10px; border-radius: 5px;"><code>
    const promise = new Promise((resolve, reject) => {
      if (true) {
        resolve("Success");
      } else {
        reject("Error");
      }
    });
      </code></pre>
    
      <h3 style="color: #34495e;">➡️ Consuming a Promise</h3>
      <pre style="background: #eef; padding: 10px; border-radius: 5px;"><code>
    promise
      .then(data => console.log("Resolved:", data))
      .catch(err => console.log("Rejected:", err));
      </code></pre>
    
      <h3 style="color: #34495e;">⏳ Simulating an API Call</h3>
      <pre style="background: #eef; padding: 10px; border-radius: 5px;"><code>
    const fetchData = new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve("Data received!");
      }, 2000);
    });
    
    fetchData.then(data => console.log(data));
      </code></pre>
    
      <h3 style="color: #34495e;">🔗 Promise Chaining</h3>
      <pre style="background: #eef; padding: 10px; border-radius: 5px;"><code>
    fetchData
      .then(data => {
        console.log(data);
        return "Next Step";
      })
      .then(step => {
        console.log(step);
      });
      </code></pre>
    
      <h3 style="color: #34495e;">❌ Callback Hell vs ✅ Promises</h3>
      <p><strong>Callback Hell:</strong></p>
      <pre style="background: #fee; padding: 10px; border-radius: 5px;"><code>
    setTimeout(() => {
      console.log("1st");
      setTimeout(() => {
        console.log("2nd");
        setTimeout(() => {
          console.log("3rd");
        }, 1000);
      }, 1000);
    }, 1000);
      </code></pre>
    
      <p><strong>Using Promises:</strong></p>
      <pre style="background: #e6ffe6; padding: 10px; border-radius: 5px;"><code>
    function wait(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    wait(1000)
      .then(() => {
        console.log("1st");
        return wait(1000);
      })
      .then(() => {
        console.log("2nd");
        return wait(1000);
      })
      .then(() => {
        console.log("3rd");
      });
      </code></pre>
    
      <h3 style="color: #34495e;">🔍 Useful Promise APIs</h3>
      <ul>
        <li><strong>Promise.all([])</strong>: Resolves when all promises are fulfilled.</li>
        <li><strong>Promise.race([])</strong>: Resolves or rejects as soon as the first one finishes.</li>
        <li><strong>Promise.allSettled([])</strong>: Waits until all promises are settled (resolved or rejected).</li>
        <li><strong>Promise.any([])</strong>: Returns the first fulfilled promise (ignores rejections).</li>
      </ul>
    
      <h3 style="color: #2c3e50;">📌 Summary</h3>
      <ul>
        <li>Promises help write cleaner async code.</li>
        <li>They avoid nested callbacks and provide better control flow.</li>
        <li>Essential for working with async operations like APIs, timers, and events.</li>
      </ul>
    </section>
    
    <section style="font-family: sans-serif; background: #f9f9f9; padding: 20px; border-radius: 10px;">
      <h2>🧵 JavaScript Promises Explained</h2>
    
      <ol>
        <li>Promise can be created using a <code>new Promise()</code> constructor function.</li>
        <li>This constructor takes a callback function as an argument.</li>
        <li>The callback function has 2 arguments: <code>resolve</code> and <code>reject</code>.</li>
        <li>Only <strong>resolve</strong> or <strong>reject</strong> can be called — nothing else.</li>
        <li>Errors can be thrown using <code>new Error('message')</code>.</li>
        <li><code>.catch()</code> is used to handle errors in the promise chain.</li>
        <li><code>.catch()</code> only catches errors from <code>.then()</code> blocks above it.</li>
        <li>You can use multiple <code>catch()</code> blocks for specific handling and one general <code>catch()</code> at the end.</li>
        <li>Always <strong>return a value</strong> from each <code>.then()</code> to forward it to the next in the chain.</li>
        <li>If it returns a Promise → the next <code>.then()</code> waits for it to resolve before executing.</li>
      </ol>
    
      <h3>📝 Homework Example</h3>
    
      <pre style="background: #efefef; padding: 15px; border-radius: 5px;">
    <code>const cart = ['shoes', 'pants', 'kurta'];
    
    createOrder(cart)
      .then(function(orderId) {
        console.log(orderId);
        return orderId;
      })
      .then(function(orderID) {
        return proceedToPayment(orderID);
      })
      .then(function({ message, amt }) {
        console.log(message, 'of amount:', amt);
        return showOrderSummary(message, amt);
      })
      .then(function({ message, amt }) {
        console.log('Your wallet has been debited by:', amt);
      })
      .catch(function(err) {
        console.log(err.message);
      })
      .then(function() {
        console.log('No matter what happens, I will get executed');
      });</code>
      </pre>
    
      <h4>📦 Helper Functions:</h4>
    
      <pre style="background: #efefef; padding: 15px; border-radius: 5px;">
    <code>function createOrder(cart) {
      const pr = new Promise(function(resolve, reject) {
        if (!validateCart(cart)) {
          return reject(new Error('Cart is not valid!'));
        }
    
        const orderId = '12345';
        if (orderId) {
          setTimeout(function() {
            resolve(orderId);
          }, 5000);
        }
      });
    
      return pr;
    }
    
    function proceedToPayment(orderID) {
      return new Promise(function(resolve, reject) {
        resolve({ message: \`Payment Successful for order id: \${orderID}\`, amt: 2500 });
      });
    }
    
    function showOrderSummary(message, amt) {
      return new Promise(function(resolve, reject) {
        if (amt >= 2000) {
          resolve({ message: \`You have ordered items that cost \${amt} RS\`, amt });
        } else {
          reject(new Error('Please buy more for discount'));
        }
      });
    }
    
    function validateCart(cart) {
      return true; // Or false to test invalid cart
    }</code>
      </pre>
    
      <p>🎯 <strong>Conclusion:</strong> Promises allow you to manage asynchronous tasks in a structured way, avoiding callback hell and giving you more control.</p>
    </section>

    <section style="font-family: sans-serif; background: #f5faff; padding: 20px; border-radius: 8px;">
      <h2 style="color: #2a3f54;">🎯38. Promise APIs + Interview Questions (Namaste JavaScript – Akshay Saini)</h2>
    
      <h3 style="color: #34495e;">🔹 Core Promise APIs</h3>
      <ul>
        <li><strong>Promise.all(iterable)</strong><br>
            Runs multiple promises in parallel and resolves when <em>all</em> succeed, or rejects if <em>any</em> fail.</li>
        <li><strong>Promise.allSettled(iterable)</strong><br>
            Waits for <em>all</em> promises to settle (fulfilled or rejected) and returns their statuses.</li>
        <li><strong>Promise.race(iterable)</strong><br>
            Resolves or rejects as soon as <em>one</em> promise settles.</li>
        <li><strong>Promise.any(iterable)</strong><br>
            Resolves with the first <em>fulfilled</em> promise, rejects only if <em>all</em> fail.</li>
      </ul>
    
      <h3 style="color: #34495e;">❓ Common Interview Questions</h3>
      <ol>
        <li><strong>What is Promise.all vs Promise.race?</strong><br>
            <em>all</em> waits for completion of all promises, <em>race</em> returns first one.</li>
        <li><strong>What is Promise.any vs Promise.allSettled?</strong><br>
            <em>any</em> resolves on first fulfilled; <em>allSettled</em> gives all results regardless of outcome.</li>
        <li><strong>Why use Promise APIs?</strong><br>
            Manage multiple async tasks efficiently and control error handling strategies.</li>
        <li><strong>What happens if one promise in Promise.all fails?</strong><br>
            Promise.all rejects immediately with that error.</li>
        <li><strong>Use-case for Promise.race?</strong><br>
            Useful for implementing timeouts or fetching from fastest source.</li>
      </ol>
    
      <h3 style="color: #34495e;">💼 Example Usage</h3>
      <pre style="background: #eef; padding: 15px; border-radius: 5px;"><code>
    const p1 = fetch('/data1');
    const p2 = fetch('/data2');
    const p3 = fetch('/data3');
    
    Promise.all([p1, p2, p3])
      .then(responses => Promise.all(responses.map(r => r.json())))
      .then(results => console.log('All data:', results))
      .catch(err => console.error('Error in one:', err));
    
    Promise.race([p1, p2, new Promise((_, reject) => setTimeout(() => reject('timeout'), 5000))])
      .then(res => console.log('First to finish:', res))
      .catch(err => console.error('Race error:', err));
      </code></pre>
    
      <h3 style="color: #34495e;">🧠 Why These APIs Matter</h3>
      <ul>
        <li><strong>Promise.all</strong>: Combine data from multiple sources</li>
        <li><strong>Promise.race</strong>: Implement timeouts or get earliest response. if all fails it will return aggregate error and array of errors in an object.</li>
        <li><strong>Promise.allSettled</strong>: Safely process all outcomes</li>
        <li><strong>Promise.any</strong>: Use the first successful response among many</li>
      </ul>
    </section> 
    
    <section style="font-family: sans-serif; background: #f0faff; padding: 20px; border-radius: 8px;">
      <h2 style="color: #2a3e50;">39.⚡ Async/Await in JavaScript (Akshay Saini – Namaste JS)</h2>
    
      <h3 style="color: #34495e;">🔹 1. <code>async</code> keyword</h3>
      <p>Marking a function <code>async</code> makes it always return a <strong>Promise</strong>. Any returned value is automatically wrapped.</p>
    
      <h3 style="color: #34495e;">🔹 2. <code>await</code> keyword</h3>
      <p>Can only be used inside <code>async</code> functions. It pauses execution until the Promise settles.</p>
    
      <h3 style="color: #34495e;">🔹 3. Execution Flow</h3>
      <ol>
        <li>Function runs until an <code>await</code>.</li>
        <li>Function is suspended and removed from call stack.</li>
        <li>Promise resolution/ rejection happens asynchronously.</li>
        <li>Once settled, continuation is queued in the microtask queue.</li>
        <li>Execution resumes from where it left off.</li>
      </ol>
    
      <h3 style="color: #34495e;">🔹 4. Example with `fetch()`</h3>
      <pre style="background: #eef; padding: 10px; border-radius: 5px;"><code>
    async function fetchData() {
      try {
        const response = await fetch('https://api.com/data');
        const data = await response.json();
        console.log(data);
      } catch (err) {
        console.error(err);
      }
    }
    
    fetchData();
      </code></pre>
    
      <h3 style="color: #34495e;">🔹 5. Behind the Scenes (Event Loop)</h3>
      <p>
        At each <code>await</code>, execution pauses. Once the awaited Promise completes, the remaining function code is resumed from the <strong>microtask queue</strong>, keeping the call stack efficient :contentReference[oaicite:17]{index=17}.
      </p>
    
      <h3 style="color: #2a3e50;">📌 Summary</h3>
      <ul>
        <li><strong>async</strong> functions always return Promises.</li>
        <li><strong>await</strong> pauses until a Promise settles.</li>
        <li>Error handling is simpler with <code>try/catch</code>.</li>
        <li>Execution resumes cleanly via the microtask queue.</li>
      </ul>
    </section>    
    
    <section style="padding:20px; background:#f0f8ff; font-family:sans-serif;">
      <h2>🔄 40. Event Loop Deep Dive (Akshay Saini)</h2>
      <h3>1. Call Stack & Web APIs</h3>
      <p>JS runs on a single call stack. Web APIs handle async tasks outside it.</p>
      <h3>2. Timer Example</h3>
      <pre><code>
    console.log("start");
    setTimeout(() => console.log("timer"), 5000);
    console.log("end");
    </code></pre>
      <p><strong>Output:</strong> start → end → (5s later) timer</p>
      <h3>3. Event Loop & Callback Queue</h3>
      <p>Event Loop pushes tasks from queues to the call stack when it’s empty.</p>
      <h3>4. Microtasks vs. Tasks</h3>
      <p>Promise callbacks go to microtasks (higher priority). Then task queue callbacks.</p>
      <h3>5. Execution Flow Example</h3>
      <pre><code>
    console.log("Start");
    setTimeout(cbT, 5000);
    fetch(...).then(cbF);
    console.log("End");
    // cbF (promise) runs before cbT (timer)
    </code></pre>
      <h3>6. Gotchas</h3>
      <ul>
        <li>0ms timeout still waits until call stack is clear</li>
        <li>Microtasks can starve callbacks</li>
        <li>Remove event listeners to avoid memory leaks</li>
      </ul>
    </section>

    <section style="font-family:sans-serif; padding:20px; background:#fefbd8;">
      <h2>41. setTimeout vs setInterval</h2>
    
      <h3>setTimeout</h3>
      <p>Used to run a function once after a specified delay.</p>
      <pre><code>
    setTimeout(() => {
      console.log("This runs after 2 seconds");
    }, 2000);
      </code></pre>
    
      <h3>setInterval</h3>
      <p>Used to run a function repeatedly at every specified interval.</p>
      <pre><code>
    setInterval(() => {
      console.log("This runs every 3 seconds");
    }, 3000);
      </code></pre>
    
      <h3>Canceling</h3>
      <pre><code>
    const timeout = setTimeout(() => console.log("Hello"), 2000);
    clearTimeout(timeout);
    
    const interval = setInterval(() => console.log("Hi"), 1000);
    clearInterval(interval);
      </code></pre>
    
      <h3>Comparison Table</h3>
      <table border="1" cellpadding="8" cellspacing="0">
        <tr>
          <th>Feature</th>
          <th>setTimeout</th>
          <th>setInterval</th>
        </tr>
        <tr>
          <td>Execution</td>
          <td>Runs once</td>
          <td>Repeats</td>
        </tr>
        <tr>
          <td>Use Case</td>
          <td>Delaying a function</td>
          <td>Recurring tasks</td>
        </tr>
        <tr>
          <td>Cancel Function</td>
          <td>clearTimeout</td>
          <td>clearInterval</td>
        </tr>
      </table>
    </section>
    
    <section style="font-family:sans-serif; background:#f3faff; padding:20px; border-radius:10px;">
      <h2>42. Microtasks vs Macrotasks</h2>
    
      <h3>🌀 Microtasks</h3>
      <ul>
        <li>Executed after current script but <strong>before</strong> any macrotasks.</li>
        <li>Examples: <code>Promise.then()</code>, <code>queueMicrotask()</code></li>
      </ul>
    
      <h3>⏱️ Macrotasks</h3>
      <ul>
        <li>Scheduled after microtasks finish.</li>
        <li>Examples: <code>setTimeout()</code>, <code>setInterval()</code></li>
      </ul>
    
      <h3>💡 Example:</h3>
      <pre style="background:#eef; padding:10px;"><code>
    console.log('Script start');
    
    setTimeout(() => {
      console.log('Macrotask: setTimeout');
    }, 0);
    
    Promise.resolve().then(() => {
      console.log('Microtask: Promise');
    });
    
    queueMicrotask(() => {
      console.log('Microtask: queueMicrotask');
    });
    
    console.log('Script end');
      </code></pre>
    
      <h4>🧾 Output:</h4>
      <pre style="background:#f9f9f9; padding:10px;"><code>
    Script start
    Script end
    Microtask: Promise
    Microtask: queueMicrotask
    Macrotask: setTimeout
      </code></pre>
    
      <h3>📊 Comparison Table</h3>
      <table border="1" cellpadding="10" cellspacing="0">
        <tr>
          <th>Aspect</th>
          <th>Microtasks</th>
          <th>Macrotasks</th>
        </tr>
        <tr>
          <td>Examples</td>
          <td>Promise.then, queueMicrotask</td>
          <td>setTimeout, setInterval</td>
        </tr>
        <tr>
          <td>Priority</td>
          <td>Higher</td>
          <td>Lower</td>
        </tr>
        <tr>
          <td>Execution Timing</td>
          <td>Before next macrotask</td>
          <td>After microtasks</td>
        </tr>
      </table>
    </section>
    
    <section style="font-family:sans-serif; background:#fffbe6; padding:20px; border-radius:10px;">
      <h2>43. What is MutationObserver?</h2>
      <p><strong>MutationObserver</strong> is a JavaScript API that watches for changes in the DOM and lets you execute a callback when those changes happen. It's used to detect modifications like:</p>
      <ul>
        <li>Node additions/removals</li>
        <li>Attribute changes</li>
        <li>Text content updates</li>
      </ul>
    
      <h3>💡 Example:</h3>
      <pre style="background:#f4f4f4; padding:10px;"><code>
    const observer = new MutationObserver(function(mutationsList) {
      for (const mutation of mutationsList) {
        console.log("Change detected:", mutation);
      }
    });
    
    observer.observe(document.getElementById("myDiv"), {
      childList: true,
      attributes: true,
      subtree: true
    });
      </code></pre>
    
      <p>This will log changes in child nodes or attributes within <code>#myDiv</code> and its children.</p>
    </section>
    
    <section style="font-family: Arial; background: #f9f9f9; padding: 20px; border-radius: 10px;">
      <h2 style="color: #2c3e50;">🌳 44. What is the DOM?</h2>
      <p>The <strong>DOM (Document Object Model)</strong> is a programming interface for HTML and XML documents. It represents the page so that programs can change the document structure, style, and content.</p>
    
      <h3 style="color: #34495e;">🔍 Visual Breakdown:</h3>
      <pre style="background: #ecf0f1; padding: 10px; border-radius: 5px;">
    HTML Document
      └── <html>
           ├── <head>
           │     └── <title>My Page</title>   ← Leaf node
           └── <body>
                 ├── <h1>Hello</h1>          ← Leaf node
                 └── <p>Welcome to DOM!</p>  ← Leaf node
      </pre>
    
      <ul>
        <li><strong>Node:</strong> Everything in the DOM is a node. It can be an element node, text node, comment node, etc.</li>
        <li><strong>Element Node:</strong> HTML elements like <code>&lt;div&gt;</code>, <code>&lt;p&gt;</code> are element nodes.</li>
        <li><strong>Text Node:</strong> The actual content inside elements like <code>"Welcome to DOM!"</code>.</li>
        <li><strong>Leaf Node:</strong> Nodes that do not have children. Example: <code>&lt;title&gt;My Page&lt;/title&gt;</code>.</li>
        <li><strong>Root Node:</strong> The top-level node of the DOM tree. For HTML, it’s <code>&lt;html&gt;</code>.</li>
      </ul>
    
      <h3 style="color: #34495e;">💡 Example DOM Tree:</h3>
      <pre style="background: #ecf0f1; padding: 10px; border-radius: 5px;">
    document
      └── html
          ├── head
          │    └── title
          │         └── "My Page"
          └── body
               ├── h1
               │    └── "Hello"
               └── p
                    └── "Welcome to DOM!"
      </pre>
    
      <p><strong>🧠 In summary:</strong> The DOM is like a family tree of your webpage. Every element is a part of the tree. JavaScript can traverse, edit, add, or remove these nodes dynamically.</p>
    </section>   
    
    <section style="font-family: Arial; background-color: #f0f8ff; padding: 20px; border-radius: 10px;">
      <h2 style="color: #2c3e50;">🧲 45. Selecting DOM Elements in JavaScript</h2>
      <p>JavaScript allows us to select and manipulate HTML elements using the DOM. Here are the most common ways to select elements:</p>
    
      <h3 style="color: #1e90ff;">1. <code>getElementById()</code></h3>
      <p>Selects a single element by its unique ID.</p>
      <pre style="background: #e8f4fc; padding: 10px; border-radius: 5px;">
    const heading = document.getElementById("main-title");
    console.log(heading.textContent);</pre>
    
      <h3 style="color: #1e90ff;">2. <code>getElementsByClassName()</code></h3>
      <p>Returns a live HTMLCollection of elements with the specified class.</p>
      <pre style="background: #e8f4fc; padding: 10px; border-radius: 5px;">
    const items = document.getElementsByClassName("item");
    console.log(items[0].textContent);</pre>
    
      <h3 style="color: #1e90ff;">3. <code>getElementsByTagName()</code></h3>
      <p>Returns a live HTMLCollection of elements with the specified tag name.</p>
      <pre style="background: #e8f4fc; padding: 10px; border-radius: 5px;">
    const paragraphs = document.getElementsByTagName("p");
    console.log(paragraphs.length);</pre>
    
      <h3 style="color: #1e90ff;">4. <code>querySelector()</code></h3>
      <p>Selects the <strong>first</strong> element that matches a CSS selector.</p>
      <pre style="background: #e8f4fc; padding: 10px; border-radius: 5px;">
    const firstButton = document.querySelector("button.primary");
    console.log(firstButton.textContent);</pre>
    
      <h3 style="color: #1e90ff;">5. <code>querySelectorAll()</code></h3>
      <p>Selects <strong>all</strong> elements that match a CSS selector and returns a NodeList.</p>
      <pre style="background: #e8f4fc; padding: 10px; border-radius: 5px;">
    const allItems = document.querySelectorAll(".item");
    allItems.forEach(item => console.log(item.textContent));</pre>
    
      <h3 style="color: #1e90ff;">🔍 Quick Reference Table</h3>
      <table style="border-collapse: collapse; width: 100%; margin-top: 10px;">
        <thead>
          <tr style="background-color: #dceefc;">
            <th style="border: 1px solid #ccc; padding: 8px;">Selector</th>
            <th style="border: 1px solid #ccc; padding: 8px;">Returns</th>
            <th style="border: 1px solid #ccc; padding: 8px;">Live/Static</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td style="border: 1px solid #ccc; padding: 8px;"><code>getElementById()</code></td>
            <td style="border: 1px solid #ccc; padding: 8px;">Single Element</td>
            <td style="border: 1px solid #ccc; padding: 8px;">Live</td>
          </tr>
          <tr>
            <td style="border: 1px solid #ccc; padding: 8px;"><code>getElementsByClassName()</code></td>
            <td style="border: 1px solid #ccc; padding: 8px;">HTMLCollection</td>
            <td style="border: 1px solid #ccc; padding: 8px;">Live</td>
          </tr>
          <tr>
            <td style="border: 1px solid #ccc; padding: 8px;"><code>getElementsByTagName()</code></td>
            <td style="border: 1px solid #ccc; padding: 8px;">HTMLCollection</td>
            <td style="border: 1px solid #ccc; padding: 8px;">Live</td>
          </tr>
          <tr>
            <td style="border: 1px solid #ccc; padding: 8px;"><code>querySelector()</code></td>
            <td style="border: 1px solid #ccc; padding: 8px;">First Matching Element</td>
            <td style="border: 1px solid #ccc; padding: 8px;">Static</td>
          </tr>
          <tr>
            <td style="border: 1px solid #ccc; padding: 8px;"><code>querySelectorAll()</code></td>
            <td style="border: 1px solid #ccc; padding: 8px;">NodeList</td>
            <td style="border: 1px solid #ccc; padding: 8px;">Static</td>
          </tr>
        </tbody>
      </table>
    
      <p style="margin-top: 20px;"><strong>Tip:</strong> Prefer <code>querySelector</code> and <code>querySelectorAll</code> for modern, flexible CSS-style selections.</p>
    </section>        

    <section style="font-family: Arial; background-color: #f9f9f9; padding: 20px; border-radius: 10px;">
      <h2 style="color: #333;">🧠 46. What is <code>addEventListener()</code>?</h2>
      <p>
        <code>addEventListener()</code> is used to attach an event (like <strong>click</strong>, <strong>mouseover</strong>, <strong>keydown</strong>, etc.) to a DOM element. It lets you run a function when that event happens.
      </p>
    
      <h3 style="color: #555;">🧪 Syntax</h3>
      <pre style="background: #eee; padding: 10px; border-radius: 5px;">
    element.addEventListener(event, callbackFunction);
      </pre>
    
      <h3 style="color: #555;">✅ Example 1: Click a button</h3>
      <pre style="background: #eee; padding: 10px; border-radius: 5px;">
    &lt;button id="myBtn"&gt;Click me&lt;/button&gt;
    
    &lt;script&gt;
      const btn = document.querySelector("#myBtn");
      btn.addEventListener("click", function () {
        alert("Button clicked!");
      });
    &lt;/script&gt;
      </pre>
    
      <h3 style="color: #555;">✅ Example 2: Mouse over an element</h3>
      <pre style="background: #eee; padding: 10px; border-radius: 5px;">
    &lt;div id="hoverBox" style="width:100px;height:100px;background:red;"&gt;&lt;/div&gt;
    
    &lt;script&gt;
      const box = document.querySelector("#hoverBox");
      box.addEventListener("mouseover", () =&gt; {
        box.style.backgroundColor = "blue";
      });
    &lt;/script&gt;
      </pre>
    
      <h3 style="color: #555;">✅ Example 3: Keydown event</h3>
      <pre style="background: #eee; padding: 10px; border-radius: 5px;">
    &lt;input type="text" id="inputBox" placeholder="Type something..." /&gt;
    
    &lt;script&gt;
      const input = document.querySelector("#inputBox");
      input.addEventListener("keydown", (event) =&gt; {
        console.log("Key pressed:", event.key);
      });
    &lt;/script&gt;
      </pre>
    
      <h3 style="color: #555;">⚙️ Why use <code>addEventListener()</code>?</h3>
      <ul>
        <li>Attach multiple listeners to the same event</li>
        <li>Clean separation of HTML and JavaScript</li>
        <li>Can be removed later using <code>removeEventListener()</code></li>
      </ul>
    
      <h3 style="color: #555;">🚫 Avoid Inline Event Handlers</h3>
      <pre style="background: #ffe6e6; padding: 10px; border-radius: 5px;">
    &lt;!-- Bad --&gt;
    &lt;button onclick="doSomething()"&gt;Click&lt;/button&gt;
      </pre>
      <pre style="background: #e6ffe6; padding: 10px; border-radius: 5px;">
    // Good
    btn.addEventListener("click", doSomething);
      </pre>
    </section>    


    <section style="font-family: Arial; background-color: #f4faff; padding: 20px; border-radius: 10px;">
      <h2 style="color: #2c3e50;">🔄 47. Event Bubbling & Capturing in JavaScript</h2>
    
      <h3 style="color: #2980b9;">What is Event Bubbling?</h3>
      <p>
        When an event occurs on a nested element, it first triggers on the **target element** and then bubbles up to its **ancestors** (parent, grandparent, etc.).
      </p>
      <p><strong>Default behavior in JavaScript</strong> is bubbling.</p>
    
      <h4>🧪 Example:</h4>
      <pre style="background: #eef6ff; padding: 10px; border-radius: 5px;">
    &lt;div id="parent"&gt;
      &lt;button id="child"&gt;Click Me&lt;/button&gt;
    &lt;/div&gt;
    
    &lt;script&gt;
      document.getElementById("parent").addEventListener("click", () =&gt; {
        console.log("Parent clicked");
      });
    
      document.getElementById("child").addEventListener("click", () =&gt; {
        console.log("Child clicked");
      });
    &lt;/script&gt;
      </pre>
      <p><strong>Output when button clicked:</strong><br>
      Child clicked<br>
      Parent clicked</p>
    
      <hr style="margin: 30px 0;">
    
      <h3 style="color: #27ae60;">What is Event Capturing?</h3>
      <p>
        In capturing phase, the event travels from the **top ancestor** (like <code>document</code>) down to the **target element**.
      </p>
      <p>It’s less commonly used and must be explicitly enabled.</p>
    
      <h4>🧪 Example:</h4>
      <pre style="background: #eafaf1; padding: 10px; border-radius: 5px;">
    &lt;div id="parent"&gt;
      &lt;button id="child"&gt;Click Me&lt;/button&gt;
    &lt;/div&gt;
    
    &lt;script&gt;
      document.getElementById("parent").addEventListener(
        "click",
        () =&gt; {
          console.log("Parent clicked (capturing)");
        },
        true // 👈 enables capturing
      );
    
      document.getElementById("child").addEventListener("click", () =&gt; {
        console.log("Child clicked");
      });
    &lt;/script&gt;
      </pre>
      <p><strong>Output when button clicked:</strong><br>
      Parent clicked (capturing)<br>
      Child clicked</p>
    
      <hr style="margin: 30px 0;">
    
      <h3 style="color: #8e44ad;">🛑 Stopping Event Propagation</h3>
      <p>You can use <code>event.stopPropagation()</code> to stop the bubbling or capturing flow.</p>
      <pre style="background: #fdf2ff; padding: 10px; border-radius: 5px;">
    element.addEventListener("click", function(event) {
      event.stopPropagation(); // Stops bubbling or capturing
    });
      </pre>
    
      <h3 style="color: #34495e;">🔍 Summary</h3>
      <ul>
        <li><strong>Bubbling</strong>: Target → Parent → Ancestors (default)</li>
        <li><strong>Capturing</strong>: Document → Parent → Target (needs true flag)</li>
        <li><strong>Use <code>stopPropagation()</code></strong> to stop event flow</li>
      </ul>
    </section>
    
    <section style="font-family: Arial, sans-serif; background: #f9f9f9; padding: 20px; border-radius: 10px;">
      <h2 style="color: #2c3e50;">48.📌 Event Delegation in JavaScript</h2>
    
      <p>
        <strong>Event Delegation</strong> is a technique where a single event listener is added to a parent element instead of individual child elements.
        It works due to the nature of <strong>event bubbling</strong>, where events move from the target element up through its ancestors.
      </p>
    
      <h3 style="color: #34495e;">🧠 Why use Event Delegation?</h3>
      <ul>
        <li>✅ Better performance (fewer event listeners in memory)</li>
        <li>✅ Dynamic content handling (works with elements added later)</li>
        <li>✅ Cleaner code and less redundancy</li>
      </ul>
    
      <h3 style="color: #34495e;">🧪 Example</h3>
      <p>Suppose we have a list of items and we want to handle clicks on each item.</p>
    
      <pre style="background: #eef; padding: 10px; border-radius: 5px;"><code>&lt;ul id="itemList"&gt;
      &lt;li&gt;Item 1&lt;/li&gt;
      &lt;li&gt;Item 2&lt;/li&gt;
      &lt;li&gt;Item 3&lt;/li&gt;
    &lt;/ul&gt;
    
    &lt;script&gt;
      const list = document.getElementById("itemList");
    
      list.addEventListener("click", function(event) {
        if (event.target.tagName === "LI") {
          alert("You clicked on " + event.target.textContent);
        }
      });
    &lt;/script&gt;
    </code></pre>
    
      <h3 style="color: #34495e;">🔍 What happens here?</h3>
      <ul>
        <li>The <code>click</code> event on any <code>&lt;li&gt;</code> bubbles up to the <code>&lt;ul&gt;</code></li>
        <li>We check <code>event.target</code> to ensure we only act on <code>&lt;li&gt;</code> elements</li>
        <li>Even if we add new <code>&lt;li&gt;</code> items later, the listener still works</li>
      </ul>
    
      <h3 style="color: #34495e;">💡 Use Cases</h3>
      <ul>
        <li>Menus or dropdowns</li>
        <li>Lists or tables with many rows</li>
        <li>Handling buttons inside a form or modal</li>
      </ul>
    
      <p style="color: #2c3e50;"><strong>🔁 Summary:</strong> Event Delegation makes your app faster and smarter by using a single listener on a parent to manage all children events using <code>event.target</code>.</p>
    </section>    

    <section style="font-family: Arial, sans-serif; background-color: #f0f8ff; padding: 20px; border-radius: 10px;">
      <h2 style="color: #2c3e50;">49.🔧 Dynamic Element Creation & Removal in JavaScript</h2>
    
      <p>
        In JavaScript, you can dynamically <strong>create</strong>, <strong>add</strong>, and <strong>remove</strong> HTML elements using the DOM API.
        This is useful for building interactive and responsive UIs without reloading the page.
      </p>
    
      <h3 style="color: #34495e;">🛠️ Creating an Element</h3>
      <pre style="background: #e8f0fe; padding: 10px; border-radius: 5px;"><code>
    // Create a new &lt;div&gt;
    const div = document.createElement("div");
    div.textContent = "I am a dynamic div!";
    div.style.background = "#d1ecf1";
    div.style.padding = "10px";
    div.style.margin = "10px 0";
    
    // Append to the body or another element
    document.body.appendChild(div);
    </code></pre>
    
      <h3 style="color: #34495e;">🧹 Removing an Element</h3>
      <pre style="background: #fff3cd; padding: 10px; border-radius: 5px;"><code>
    const elementToRemove = document.getElementById("remove-me");
    elementToRemove.remove(); // Direct removal (modern browsers)
    
    // OR using parentElement
    elementToRemove.parentElement.removeChild(elementToRemove); // Works in older browsers
    </code></pre>
    
      <h3 style="color: #34495e;">🎯 Example: Add & Remove Button</h3>
      <pre style="background: #e2ffe2; padding: 10px; border-radius: 5px;"><code>
    &lt;button id="addBtn"&gt;Add Box&lt;/button&gt;
    
    &lt;script&gt;
    document.getElementById("addBtn").addEventListener("click", function () {
      const box = document.createElement("div");
      box.textContent = "Click to remove me";
      box.style.background = "#cce5ff";
      box.style.margin = "10px";
      box.style.padding = "10px";
      box.style.cursor = "pointer";
    
      // Click to remove the element
      box.addEventListener("click", function () {
        box.remove();
      });
    
      document.body.appendChild(box);
    });
    &lt;/script&gt;
    </code></pre>
    
      <h3 style="color: #34495e;">💡 Tips</h3>
      <ul>
        <li>Use <code>createElement</code> for dynamic UI generation.</li>
        <li>Always append using <code>appendChild</code> or <code>append</code>.</li>
        <li>Use <code>remove()</code> to delete elements when needed.</li>
      </ul>
    
      <p style="color: #2c3e50;"><strong>✅ Summary:</strong> Dynamic DOM manipulation allows you to create reactive, fast interfaces without page reloads. You can add, change, or delete elements on the fly using JavaScript.</p>
    </section>    

    <section style="font-family: Arial, sans-serif; background-color: #f4f9ff; padding: 20px; border-radius: 10px;">
      <h2 style="color: #2c3e50;">50.🌑 Shadow DOM in JavaScript</h2>
    
      <p>
        The <strong>Shadow DOM</strong> is a part of Web Components that allows you to encapsulate a piece of the DOM and CSS
        so that it's isolated from the rest of the document. This ensures styles and behavior don’t accidentally leak in or out.
      </p>
    
      <h3 style="color: #34495e;">🎯 Why Shadow DOM?</h3>
      <ul>
        <li>Encapsulation: Styles and markup inside shadow DOM won’t affect the rest of the page.</li>
        <li>Scoped styles: Prevents CSS conflicts across components.</li>
        <li>Used in Web Components and frameworks like Lit, Stencil, etc.</li>
      </ul>
    
      <h3 style="color: #34495e;">🔧 Creating a Shadow DOM</h3>
      <pre style="background: #ecf7ff; padding: 10px; border-radius: 5px;"><code>
    // Step 1: Create a host element
    const host = document.createElement('div');
    document.body.appendChild(host);
    
    // Step 2: Attach a shadow root to the host
    const shadowRoot = host.attachShadow({ mode: 'open' });
    
    // Step 3: Add HTML/CSS inside shadow DOM
    shadowRoot.innerHTML = `
      &lt;style&gt;
        p {
          color: blue;
          font-weight: bold;
        }
      &lt;/style&gt;
      &lt;p&gt;This is inside the Shadow DOM!&lt;/p&gt;
    `;
    </code></pre>
    
      <h3 style="color: #34495e;">🕳️ Shadow DOM Modes</h3>
      <ul>
        <li><code>open</code>: The shadow root is accessible via JavaScript (<code>element.shadowRoot</code>).</li>
        <li><code>closed</code>: The shadow root is hidden from outside access.</li>
      </ul>
    
      <h3 style="color: #34495e;">📦 Example</h3>
      <pre style="background: #fff8e1; padding: 10px; border-radius: 5px;"><code>
    &lt;div id="shadow-host"&gt;&lt;/div&gt;
    
    &lt;script&gt;
      const host = document.getElementById("shadow-host");
      const shadow = host.attachShadow({ mode: "open" });
      shadow.innerHTML = `
        &lt;style&gt;
          div {
            background: #cce5ff;
            padding: 10px;
            border-radius: 5px;
          }
        &lt;/style&gt;
        &lt;div&gt;Shadow DOM Content&lt;/div&gt;
      `;
    &lt;/script&gt;
    </code></pre>
    
      <h3 style="color: #34495e;">📌 Summary</h3>
      <p>
        The Shadow DOM gives us a way to build <strong>modular, encapsulated UI components</strong> without worrying about
        style conflicts or leaking behavior. It's a cornerstone of modern frontend component architecture.
      </p>
    </section>
    

    <section style="font-family: Arial, sans-serif; background: #f0f9ff; padding: 20px; border-radius: 8px;">
      <h2 style="color: #2c3e50;">51.🔑 Understanding the <code>this</code> Keyword (Akshay Saini)</h2>
    
      <h3 style="color: #34495e;">📌 Core Rules</h3>
      <ul>
        <li><strong>Global/Function scope</strong>: <code>this</code> refers to <code>window</code> (or <code>undefined</code> in strict mode).</li>
        <li><strong>Method Call</strong>: <code>this</code> refers to the object owning the method.</li>
        <li><strong>Constructor (with <code>new</code>)</strong>: <code>this</code> points to the newly created object.</li>
        <li><strong>Explicit binding</strong>: Using <code>call</code>, <code>apply</code>, or <code>bind</code> sets <code>this</code>.</li>
        <li><strong>Arrow Functions</strong>: <code>this</code> is inherited lexically from the parent scope—arrow functions don’t have their own.</li>
      </ul>
    
      <h3 style="color: #34495e;">🧪 Examples</h3>
    
      <h4>1. Global/Function</h4>
      <pre style="background: #eef; padding: 10px; border-radius: 5px;"><code>
    function foo() {
      console.log(this); // Window or undefined in strict mode
    }
    foo();
      </code></pre>
    
      <h4>2. Method Call</h4>
      <pre style="background: #eef; padding: 10px; border-radius: 5px;"><code>
    const obj = {
      name: "Alice",
      greet() { console.log(this.name); }
    };
    obj.greet(); // "Alice"
      </code></pre>
    
      <h4>3. Constructor</h4>
      <pre style="background: #eef; padding: 10px; border-radius: 5px;"><code>
    function Person(name) {
      this.name = name;
    }
    const p = new Person("Bob");
    console.log(p.name); // "Bob"
      </code></pre>
    
      <h4>4. Explicit Binding</h4>
      <pre style="background: #eef; padding: 10px; border-radius: 5px;"><code>
    function greet() {
      console.log(this.name);
    }
    const user = { name: "Carol" };
    greet.call(user); // "Carol"
      </code></pre>
    
      <h4>5. Arrow Function</h4>
      <pre style="background: #eef; padding: 10px; border-radius: 5px;"><code>
    const obj = {
      name: "Dan",
      arrow: () => console.log(this.name),
      method: function() {
        console.log(this.name);
        setTimeout(() => console.log(this.name), 0); // inherits this
      }
    };
    obj.arrow();   // undefined (lexical)
    obj.method();  // "Dan", then "Dan"
      </code></pre>
    
      <h3 style="color: #34495e;">🧠 Key Takeaways</h3>
      <ul>
        <li>Arrow functions don’t get their own <code>this</code>.</li>
        <li>Explicit binding <em>(call/apply/bind)</em> overrides default behavior.</li>
        <li>Constructors with <code>new</code> assign <code>this</code> to the new object.</li>
      </ul>
    
      <h3 style="color: #2c3e50;">💡 In Summary</h3>
      <p>
        Think of <code>this</code> as a pointer that depends on how a function is executed—not where it’s written. Following these rules makes behavior predictable.
      </p>
    </section>
    
    <section style="font-family: Arial, sans-serif; background-color: #f9f9ff; padding: 20px; border-radius: 10px;">
      <h2 style="color: #4a4a88;">52.🟪 Immediately Invoked Function Expression (IIFE)</h2>
    
      <p><strong>IIFE</strong> is a JavaScript function that runs immediately after it is defined.</p>
    
      <h3 style="color: #333;">🔹 Syntax</h3>
      <pre style="background-color: #eef; padding: 10px; border-radius: 6px;"><code>(function () {
      // Code inside IIFE
      console.log("This runs immediately");
    })();</code></pre>
    
      <pre style="background-color: #eef; padding: 10px; border-radius: 6px;"><code>(() => {
      console.log("Arrow IIFE");
    })();</code></pre>
    
      <h3 style="color: #333;">🔹 Explanation</h3>
      <ul>
        <li>The first <code>()</code> turns the function into an expression.</li>
        <li>The second <code>()</code> invokes it immediately.</li>
      </ul>
    
      <h3 style="color: #333;">🔹 Use Cases</h3>
      <ul>
        <li>To avoid polluting the global scope.</li>
        <li>To encapsulate logic and variables.</li>
        <li>To run setup code immediately.</li>
      </ul>
    
      <h3 style="color: #333;">🔹 Example</h3>
      <pre style="background-color: #eef; padding: 10px; border-radius: 6px;"><code>(function () {
      var secret = "I am private";
      console.log(secret); // ✅ I am private
    })();
    
    console.log(secret); // ❌ ReferenceError: secret is not defined</code></pre>
    
      <h3 style="color: #333;">🔹 IIFE with Parameters</h3>
      <pre style="background-color: #eef; padding: 10px; border-radius: 6px;"><code>(function (name) {
      console.log(`Hello, ${name}`);
    })("Pratik");</code></pre>
    
      <h3 style="color: #333;">✅ Summary Table</h3>
      <table style="width: 100%; border-collapse: collapse; background-color: #fff; border: 1px solid #ccc;">
        <thead style="background-color: #dde;">
          <tr>
            <th style="padding: 8px; border: 1px solid #ccc;">Feature</th>
            <th style="padding: 8px; border: 1px solid #ccc;">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td style="padding: 8px; border: 1px solid #ccc;">IIFE stands for</td>
            <td style="padding: 8px; border: 1px solid #ccc;">Immediately Invoked Function Expression</td>
          </tr>
          <tr>
            <td style="padding: 8px; border: 1px solid #ccc;">Purpose</td>
            <td style="padding: 8px; border: 1px solid #ccc;">Run function immediately and isolate scope</td>
          </tr>
          <tr>
            <td style="padding: 8px; border: 1px solid #ccc;">Common Use</td>
            <td style="padding: 8px; border: 1px solid #ccc;">Avoid global pollution, setup logic</td>
          </tr>
          <tr>
            <td style="padding: 8px; border: 1px solid #ccc;">Syntax</td>
            <td style="padding: 8px; border: 1px solid #ccc;">Wrap in <code>()</code> and call with <code>()</code></td>
          </tr>
        </tbody>
      </table>
    </section>        
  </body>
</html>
